[{"title":"hexo+github搭博客","path":"/2023/06/13/hexo+github搭博客/","content":"hexo+github搭建博客网站官方教程 详细教程查看文档 | Hexo 安装git1、设置用户信息12git config --global user.name &quot;xxx&quot; # 用户名git config --global user.email &quot;xxx@xxx.com&quot; # 邮箱 2、生成新的SSH key1ssh-keygen -t rsa -C &quot;邮箱地址&quot; 3、添加SSH key到GitHub 登录GitHub，点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 然后把~.ssh\\id_rsa.pub中的内容粘贴进去 4、github上建立仓库 点New Repository，注意Repository名字是特定的，Github Pages Repository名字必须是账号名.github.io 安装nodejs1、下载淘宝镜像下载压缩版的二进制文件zip包 2、配置环境解压zip，在电脑系统环境中修改Path路径，添加在结尾添加;C:\\Program Files ode-v10.16.3-win-x64 Path=...;C:\\Program Files ode-v10.16.3-win-x64; 3、命令验证12node -v npm -v 4、配置全局模块安装目录 可以配置全局模块安装目录，文件会保存至 「全局模块的安装目录node_modules」「缓存目录npm-cache」 123npm config set prefix &quot;C:\\Program Files ode-v10.16.3-win-x64&quot; npm config set cache &quot;C:\\Program Files ode-v10.16.3-win-x64 pm-cache&quot;npm install xxx -g # 全局安装xxx，可选参数 -g，g 代表 global，全局安装的意思 5、npm更换淘宝镜像1npm config set registry https://registry.npm.taobao.org 安装 Hexo1、安装 要在cmd管理员模式下进行安装，命令如下 12npm install -g hexo-cli # 安装hexohexo -v # 查看版本 2、建立博客文件夹 自己建立一个文件夹放博客相关的文件，如mblog，下面命令对博客文件夹进行初始化 123cd mbloghexo initnpm install 3、安装 Git 相关模块123npm install hexo-deployer-git --save # 将文章部署到github上的模块npm install hexo-generator-feed --save # 安装RSS插件npm install hexo-generator-sitemap --save # 添加Sitemap,加速网页收录速度 4、配置远端地址编辑 _config.yml 【：的后面是有一个空格的，不然后面会出错】 123456789101112131415deploy: type: git repository: git@github.com:test/test.github.io.git,master//或者deploy:type: gitrepo: https://github.com/JiLuanxi/jiluanxi.github.io.gitbranch: message: //参数解释repo：直接复制 Repo 的URL即可branch：默认 push 到哪个分支。如果为空，则默认 push 到 master 分支message：默认提交信息。如果为空，则默认为 Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125; 5、使用hexo1hexo g &amp;&amp; hexo s # 在本地生成静态页面并预览 6、hexo主要目录 _config.yml：整个站点的配置文件 source&#x2F;_posts： 发表的博文目录 source&#x2F;_drafts：彩稿文件目录 themes：主题文件目录 public：执行hexo g命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 7、主题 简洁美观：https://xaoxuu.com/wiki/stellar 8、常用命令12345hexo n # == hexo new 建立新文章，默认在_posts下，layout=&quot;draft&quot;时发布的是草稿hexo p # == hexo publish 将_drafts下的文件放到_posts下，也就是发布草稿hexo g # == hexo generate 生成静态网页hexo s # == hexo server 启动预览服务器，开启-d选项时可以预览草稿hexo d # == hexo deploy 发布到远程服务器，开启--generate选项可以在deploy前自动generate","tags":["hexo","博客","github"],"categories":["教程"]},{"title":"在线工具集","path":"/2023/06/12/在线工具集/","content":"真心话大冒险 这是一款真心话大冒险的现场多人游戏，可以和一群朋友一起玩耍。 试试：真心话大冒险小游戏 中奖模拟 这款工具可以自定义中奖率，精确到小数。欧皇就是我，体验一下万里挑一的感觉。 试试：中奖模拟小游戏","tags":["html","在线工具","多人小游戏"],"categories":["工具"]},{"title":"Java、Tomcat和Mysql安装和配置","path":"/2023/06/10/Java、Tomcat和Mysql安装和配置/","content":"Tomcat 和 Mysql 是解压版教程，Java要下载jdk安装。 Java 环境变量配置12345678变量名：【JAVA_HOME】 变量值：【D:\\Program Files\\Java\\jdk1.8.0_92】（jdk 安装路径，替换为你自己的）变量名：【Path】 变量值：【;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 】（加入 Path 中）变量名：【CLASSPATH】 变量值：【.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;】（. 不能漏） 这是很容易搞错的，在此记录。 Tomcat 免安装版配置 如果之前安装注册了，打开管理员 cmd，运行 sc delete Tomcat9 （我的 Tomcat 的服务名为 Tomcat9，换成你自己的，一般换个版本号就行） 环境变量配置：12345678变量名：【TOMCAT_HOME】 变量值：【D:\\apache-tomcat-9.0.8】（Tomcat 解压路径，替换为你自己的，版本升级只需修改此处）变量名：【CATALINA_HOME】 变量值：【%TOMCAT_HOME%】变量名：【CATALINA_BASE】 变量值：【%TOMCAT_HOME%】 修改文件 修改 D:\\apache-tomcat-9.0.8\\bin 下的 startup.bat 和 shutdown.bat 文件，首行加入下面两行： 12SET JAVA_HOME=C:\\Program Files\\Java\\jdk1.8.0_60 SET CATALINA_HOME=D:\\apache-tomcat-8.0.39 （替换为你自己的路径） 注册 Tomcat 为 windows 系统服务 管理员的身份打开 windows 命令行，进入到 D:\\apache-tomcat-9.0.8\\bin 目录下，（不会自行百度），执行 service.bat install 命令，完成注册。配置完成。 双击 bin 目录 tomcat9.exe 再点击运行，或在管理员命令行中用 net start Tomcat9 开启，用 net start Tomcat9 关闭。（Tomcat9 是服务名，一般换成自己的版本，实在不知道可以在 window 服务中查到名字） Mysql 免安装版配置 如果之前安装注册了，打开管理员 cmd，运行 sc delete mysql 环境变量配置：12变量名：【Path】 变量值：【D:\\mysql-5.5.32\\bin】（加入 Path 中，路径替换为你自己的） 新建 my.ini 文件 在 D:\\mysql-5.5.32 目录下新建 my.ini 文件，内容为 123456789101112131415# 设置mysql客户端默认字符集default-character-set=utf8[mysqld]# 设置mysql的安装目录basedir=D:\\mysql-5.5.32\\# 设置mysql数据库的数据的存放目录datadir=D:\\mysql-5.5.32\\data#设置3306端口port=3306# 允许最大连接数max_connections=200# 服务端使用的字符集默认为八比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 注册 Mysql 为 windows 系统服务 管理员的身份打开 windows 命令行，进入到 D:\\mysql-5.5.32\\bin 目录下，（不会自行百度）, 执行 mysqld install 命令，完成注册。 其他命令123456net start mysql //启动服务。mysql -u root -p //登录root，默认无密码//登录后，修改密码：mysql&gt;use mysql;mysql&gt;update user set password=(&quot;123456&quot;) where user=&#x27;root&#x27;;mysql&gt;flush privileges; 配置完成了，类似上面启动，在管理员命令行中用 net start mysql 开启，用 net start mysql 关闭。（不用加版本号）","tags":["java","tomcat","mysql"],"categories":["软件安装"]},{"title":"ajax用法和json格式了解","path":"/2023/06/09/ajax用法和json格式了解/","content":"jQuery 调用 ajax 方法概述 ajax（异步 JavaScript 和 XML）： jQuery 可以通过 $.Ajax() 和 load(),$.get(),$.post(),$.getScript(),$.getJSON() 这些方法来使用 ajax。（注意下面提到的方法用，中括号括起来的参数，表示可选参数！） $.load() 方法1$(&quot;#id&quot;).load(url, [data], [callback]); url: 要请求的页面地址data：要发送到服务器的 key&#x2F;value 数据，没有指定传递方式默认为 get 方式callback：请求完成时的回调函数（无论成败都调用），匿名函数定义如下： 12345function(responseText, textStates, XMLHttpRequest)&#123;\t//responseText：请求返回的内容 //textStates：请求状态：success error notmodified timeout4种 //XMLHttpRequest：XMLHttpRequest对象&#125; $.get() 方法123$(&quot;#btn&quot;).click(function()&#123; $.get( url, [data], [callback], [type]);&#125;); url: 要请求的页面地址（可以用 php 页面处理后台数据）data：要发送到服务器的 key&#x2F;value 数据，没有指定传递方式默认为 get 方式callback：该回调函数只会在成功时调用，匿名函数定义如下 1234function(data, textStatus)&#123; //data：返回的内容，可以是XML文档，json文件，XHML片段等等 //textStatus：请求状态：success error notmodified timeout4种&#125; type：服务器返回数据的格式（有 json，xml，text，html，script） $.post() 方法 $.post() 的用法和 $.get() 类似，不再累述，但我们要知道 get 和 post 两种方式传递数据的区别 总结为四字口诀：数长可缓 12345 post get数据类型 文件和二进制文件 文本长度 无限 255可见性 不可见 可见缓存 无 有 $.getScript( ) 方法用于在需要的时候加载 JavaScript 文件 1$.getScript(url, callback); url：请求地址 (一般是 js 文件，文件里写 js 处理问题的函数)callback：回调匿名函数（必选参数）一个小栗子： 12345$(&quot;button&quot;).click(function()&#123; $.getScript(&quot;hello.js&quot;, function() &#123; alert(sayHello()); //调用hello.js中的sayHello()方法 &#125;);&#125;); $.getJson( ) 方法用于在需要的时候加载 SON 文件 1$.getJSON(url, callback); url：请求地址callback：回调匿名函数（必选参数），定义如下 1234function(data)&#123; // 遍历json数据//1、$.each(data，function(index, value)&#123;//输出index索引，value变量或内容&#125;);//2、传统的for循环遍历&#125; $.Ajax()方法前面的方法都是基于此方法实现的，所以这个方法可以实现上面 4 个方法的所有功能。 123456789101112131415$.ajax(&#123;url:&quot;account.php&quot;, // 请求地址type: get, // &quot;get | post | put | delete &quot; 默认是getdata: &#123;&quot;user&quot;:&quot;jack&quot;,&quot;pwd&quot;:&quot;1234&quot;&#125;, // 要发送到服务器的key/value数据dataType:&quot;text&quot;, // 请求数据类型（json，xml，text，html，script 和 jsonp ）success:function(data,dataTextStatus,jqxhr)&#123; console.log(dataTextStatus); console.log(jqxhr); &#125;, // 请求成功时error:function(jqxhr,textStatus,error)&#123; console.log(jqxhr); console.log(textStatus); &#125; // 请求失败时&#125;);//(6个参数，是用逗号隔开每个参数，最后可以不用逗号) 对 JavaScript 与 JSON 的了解 描述 JSON 格式数据的语法采用了 JS 对象字面量的表示方法，但是不能把 JS 对象看做是 JSON，它们只是语法相似，和 XML 一样 JSON 只是一种存储数据的类型，不算编程语言。下面会具体对比它们。 完整的 JavaScript 实现核心（ECMAScript）文档对象模型（DOM）浏览器对象模型（BOM） JavaScript 数据类型总共有六种类型，可以用 typeof 操作符检测类型，具体如下：“undefined”——如果这个值未定义；“boolean”——如果这个值是布尔值；“string”——如果这个值是字符串；“number”——如果这个值是数值；“object”——如果这个值是对象或 null；“function”——如果这个值是函数 for-in 遍历用来枚举对象的属性（注意：对象的属性没有顺序） 1for (property in expression) statement 小栗子： 12345678function a(obj)&#123; if(obj != null || obj != undefined)&#123; for(var pro in obj)&#123; document.write(pro+&quot;&lt;br&gt;&quot;); &#125; &#125;\t&#125;a(window); // 遍历window对象的所以属性 JSON 数据格式概述 JSON: JavaScript Object Notation（中文名：JavaScript 对象表示法），它和 JavaScript 对比如下：1、JSON 中没有变量的概念，没有 (不用) 声明变量2、没有末尾的分号3、对象的属性必须加双引号 数据类型 与 JavaScript 对比：1、简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON 不支持 JavaScript 中的特殊值 undefined。2、对象 {}：是一组无序的键值对3、数组 []：表示一组有序的值的列表下面是一个栗子： 12345678910111213141516171819202122232425262728[ &#123; &quot;age&quot;: 18, &quot;name&quot;: &quot;张三&quot;, &quot;school&quot;: &#123; &quot;location&quot;: &quot;位置&quot;, &quot;name&quot;: &quot;一中&quot;, &quot;teacher&quot;: [ &quot;老师一&quot;, &quot;老师二&quot; ], &quot;year&quot;: 2018 &#125; &#125;, &#123; &quot;age&quot;: 18, &quot;name&quot;: &quot;李四&quot;, &quot;school&quot;: &#123; &quot;location&quot;: &quot;位置&quot;, &quot;name&quot;: &quot;一中&quot;, &quot;teacher&quot;: [ &quot;老师一&quot;, &quot;老师二&quot; ], &quot;year&quot;: 2017 &#125; &#125;] JSON 对象的方法 JSON 对象有两个方法：stringify() 和 parse()1、把 JavaScript 对象序列化为 JSON 字符串（默认情况下，JSON.stringify() 输出的 JSON 字符串不包含任何空格字符或缩进）2、把 JSON 字符串解析为原生 JavaScript 值 JSON 与 XML 的写法对比json 栗子： 12345&#123;&quot;employees&quot;:[ &#123;&quot;firstName&quot;:&quot;John&quot;, &quot;lastName&quot;:&quot;Doe&quot;&#125;, &#123;&quot;firstName&quot;:&quot;Anna&quot;, &quot;lastName&quot;:&quot;Smith&quot;&#125;, &#123;&quot;firstName&quot;:&quot;Peter&quot;, &quot;lastName&quot;:&quot;Jones&quot;&#125;]&#125; xml 栗子： 1234567891011&lt;employees&gt; &lt;employee&gt; &lt;firstName&gt;John&lt;/firstName&gt; &lt;lastName&gt;Doe&lt;/lastName&gt; &lt;/employee&gt; &lt;employee&gt; &lt;firstName&gt;Anna&lt;/firstName&gt; &lt;lastName&gt;Smith&lt;/lastName&gt; &lt;/employee&gt; &lt;employee&gt; &lt;firstName&gt;Peter&lt;/firstName&gt; &lt;lastName&gt;Jones&lt;/lastName&gt; &lt;/employee&gt;&lt;/employees&gt;","tags":["ajax","json","jquery"],"categories":["编程"]},{"title":"Java简单图形编程","path":"/2023/06/08/Java简单图形编程/","content":"今天这篇博客，讲的是部分 Java GUI 图形界面的用法，在开发一些需要服务端和客户端进行通信时，我们常常会写个界面，这时候做 java 后台的可能对图形界面比较陌生，所以在此我要简单聊一聊常见图形界面布局的方法。主要讲网格布局和边界布局。 Java GUI 两个比较常用的布局方法网格布局 (GridLayout) 先上代码，代码中有详细注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package gridlayout;import java.awt.GridLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.ButtonGroup;import javax.swing.JButton;import javax.swing.JCheckBox;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JPasswordField;import javax.swing.JRadioButton;import javax.swing.JTextField;public class Demo1 extends JFrame &#123;\t//定义个控件\tprivate JPanel[] ps = new JPanel[5]; //定义并分配了空间，没分配空间就操作会报空指针异常\tprivate JLabel l1, l2, l3, l4;\tprivate JTextField tf1;\tprivate JPasswordField pwf1;\tprivate JButton btn1, btn2;\tprivate JRadioButton rb1, rb2;\tprivate JCheckBox cb1, cb2;\tprivate ButtonGroup bg1, bg2; public Demo1() &#123; //初始化各控件 for (int i = 0; i &lt; ps.length; i++) &#123; ps[i] = new JPanel(); &#125; l1 = new JLabel(&quot;用户名：&quot;); l2 = new JLabel(&quot;密码：&quot;); l3 = new JLabel(&quot;性别：&quot;); l4 = new JLabel(&quot;爱好：&quot;); tf1 = new JTextField(15); pwf1 = new JPasswordField(15); btn1 = new JButton(&quot;登录&quot;); btn2 = new JButton(&quot;取消&quot;); rb1 = new JRadioButton(&quot;男&quot;); rb2 = new JRadioButton(&quot;女&quot;); bg1 = new ButtonGroup(); //使用单选按钮时，要使用ButtonGroup！复选按钮（框）不用！ bg1.add(rb1); bg1.add(rb2); cb1 = new JCheckBox(&quot;唱歌&quot;); cb2 = new JCheckBox(&quot;跳舞&quot;); //设置布局，LayoutManager manager = new GridLayout(行rows，列cols); setLayout(new GridLayout(5, 1)); //控件添加到面板Jpanel ps[0].add(l1); ps[0].add(tf1); ps[1].add(l2); ps[1].add(pwf1); ps[2].add(l3); ps[2].add(rb1); //注意：不能添加bg1，它算是对象的容器 ps[2].add(rb2); ps[3].add(l4); ps[3].add(cb1); ps[3].add(cb2); ps[4].add(btn1); ps[4].add(btn2); for (int i = 0; i &lt; ps.length; i++) &#123; add(ps[i]);//或写成this.add(ps[i]));原因见下 &#125; //用匿名内部类来监听事件源产生的事件 btn2.addActionListener(new ActionListener() &#123; //实现ActionListener的actionPerformed方法 @Override public void actionPerformed(ActionEvent e) &#123; JOptionPane.showMessageDialog(null, &quot;即将关闭&quot;); //弹出提示框 dispose(); //dispose方法是关闭窗体，并释放一部分资源 &#125; &#125;); //设置JFrame窗体的各属性,(注：因为这些都是父类JFrame的方法，没有歧义时，我就省略了this，不想写一些多余的) setTitle(&quot;GridLayout测试&quot;); setSize(500, 400); setLocation(300, 100); setVisible(true); //设置窗体可见，不能忘了！ //使用 System exit 方法退出应用程序。仅在应用程序中使用。如果不写，控制台会一直运行，不会退出 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;\tpublic static void main(String[] args) &#123; Demo1 demo1 = new Demo1();\t&#125;&#125; 运行效果图： 上面主要的思想是，每行可以放一个 JPanel 面板容器，里面又可以添加控件或容器，然后做成你想要的几行几列的网格布局。 边界布局 (BorderLayout) 1、布局方位： 2、注意控件会自动调整： 1）北和南位置控件各占上、下一行，控件宽度将自动布满整行。 2）东、西和中间三个位置控件共占中间一行。 3）东南西北四个位置，不管哪里缺了控件，中间的控件都会自动占据那里。 具体效果大家可以自己去试试，下面看看我的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package borderlayout;import java.awt.BorderLayout;import javax.swing.JButton;import javax.swing.JComboBox;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTextArea;import javax.swing.JTextField;public class Demo2 extends JFrame &#123; private JLabel l1; private JTextArea ta1; private JScrollPane sp1; private JComboBox&lt;String&gt; cb1; private JTextField tf1; private JButton btn1; private JPanel p1; public Demo2() &#123; //初始化 l1 = new JLabel(&quot;聊天界面&quot;); ta1 = new JTextArea(); //不写参数，会自动调节大小 sp1 = new JScrollPane(ta1); String[] strs = &#123;&quot;非匿名&quot;, &quot;匿名&quot;&#125;; cb1 = new JComboBox&lt;String&gt;(strs); tf1 = new JTextField(15); btn1 = new JButton(&quot;发送&quot;); p1 = new JPanel(); p1.add(cb1); p1.add(tf1); p1.add(btn1); add(l1, BorderLayout.NORTH); add(sp1, BorderLayout.CENTER); add(p1, BorderLayout.SOUTH); setTitle(&quot;BorderLayout测试&quot;); setSize(500, 400); setLocation(300, 100); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125; public static void main(String[] args) &#123; Demo2 demo2 = new Demo2(); &#125;&#125; 运行效果图： 上面就是中间的控件自动占据了东、西俩位置，因为就东、西俩位置没控件。 JOptionPane 消息提示框 因为我们在写界面时，可能会要弹出一些提示框，上面的第一个例子就用到了，在此我简单介绍一下三种消息常用的提示框方法（其实有四种，这三种比较常用和简单）： 1、showConfirmDialog 询问确认问题，如是 &#x2F; 否 &#x2F; 取消。 2、showInputDialog 提示输入一些内容。 3、showMessageDialog 告诉用户发生了什么事。 简单的用法就是这样：JOptionPane.showMessageDialog(null,” 要显示的文字”)，把 showMessageDialog 换成你想要的方法即可。如果想要详细学习 JOptionPane 的用法，可以参考官方文档, 是英文的，英文不好的童鞋记得用下谷歌浏览器自带的翻译。好了图形界面的简单编程就讲到这，拜拜了！","tags":["java","JavaGUI"],"categories":["编程"]},{"title":"java线程状态","path":"/2023/06/07/java线程状态/","content":"线程的状态1、新建状态 (new) 用 new 等方法创建了线程对象，但线程至今尚未启动。（下面说明怎么启动） 2、可运行状态 (runnable) 创建线程对象后，其他线程(比如 main 线程）调用了该对象的 start() 方法启动。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权 。 3、运行状态 (running) 在可运行状态(runnable) 的基础上获得了 cpu 时间片（timeslice）的线程，称运行状态的线程，在这执行程序代码。 4、阻塞状态 (block) 阻塞状态是指线程因为某种原因放弃了 cpu 使用权，即让出了 cpu 时间片（timeslice），暂时停止运行。直到线程进入可运行(runnable) 状态，才有机会再次获得 cpu 时间片（timeslice）转到运行 (running) 状态。阻塞的情况分三种： (1)、 等待阻塞：运行 (running) 的线程执行 wait()方法，JVM 会把该线程放入等待队列 (waitting queue) 中。 (2)、 同步阻塞：运行 (running) 的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池 (lock pool) 中。 (3)、 其他阻塞：运行 (running) 的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I&#x2F;O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入可运行 (runnable) 状态。 5、死亡 (dead) 线程 run()、main() 方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。 线程的状态转换图 线程中一些方法的解释 Thread.yield()：暂停当前正在执行的线程对象，并执行其他线程。使有相同优先级的线程有机会执行。 join()：（ 必须要在线程启动后才能使用）调用 join() 方法的线程将被优先执行，直到此线程运行结束，当前线程才能继续运行。 调用 join(long mills)方法的线程将被优先执行，直到此线程运行结束或者经过 mills 时间，当前线程才能继续运行。 sleep()： 让线性休眠，必须指定时间，时间到了后，线程会自动醒来，在休眠的时候，不会释放锁的所有权，当休眠时间到后，会继续执行 wait()： 让线程暂停，可以指定时间，也可以不指定，可以通过 notity、notityAll 释放锁的所有权。","tags":["java","多线程"],"categories":["编程"]},{"title":"设计模式-工厂模式 (Factory Pattern)","path":"/2023/06/06/设计模式-工厂模式 (Factory Pattern)/","content":"设计模式中的工厂模式。它属于创建型模式，那么什么是创建行模式呢，它主要就是将类或者对象的实例化过程抽象起来，可以分为类的创建型模式和对象的创建型模式两类，而工厂模式就属于对象的创建型模式。 工厂模式简介 工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。（通俗说就是工厂会根据不同的情况，为我们创建不同的产品。） 分类 1）简单工厂模式 - Simple Factory Pattern 2）工厂方法模式 - Factory Method Pattern 3）抽象工厂模式 - Abstract Factory Pattern 这三种模式从上到下逐步抽象，并且一个比一个更具有一般性。GoF 在《设计模式》一书中，将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。所以也有人将工厂模式分为两类，在这我更偏向把它分为三类，后面分三类举例讲解。 三种工厂模式用法1、简单工厂模式： 专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。它又称为静态工厂方法模式。它的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。 2、工厂方法模式： 在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。有一个抽象的 Factory 类（可以是抽象类和接口），这个类将不在负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。 3、抽象工厂模式： 抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类， 可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。 代码演示 看了上面的用法，大家可能有些不能理解，下面就用三个非常简单的栗子阐述清楚这些概念： 1、简单工厂模式例子123456789101112131415161718192021222324252627282930313233343536373839404142434445package simple;/** * 简单工厂模式：生产多种型号宝马产品 * 补充：开闭原则——&gt;对扩展的开放，对修改的关闭 * 缺点：每增加一种新型车,工厂类中需要增加相应的case，违背开闭原则（对扩展的开发，对修改的关闭） * 弥补：提出工厂方法模式，定义如下 * 工厂类定义成了接口,而每新增的车种类型,就增加该车种类型对应工厂类的实现, * 这样工厂的设计就可以扩展了,而不必去修改原来的代码。 *///产品类interface BMW&#123;\t&#125;class BMW320 implements BMW&#123;\tpublic BMW320() &#123; System.out.println(&quot;制造 BMW320&quot;);\t&#125;&#125;class BMW523 implements BMW&#123;\tpublic BMW523() &#123; System.out.println(&quot;制造 BMW523&quot;);\t&#125;&#125;//工厂类class Factory&#123;\tpublic BMW createBMW(int type) &#123; //根据参数不同，返回不同的产品（对象） switch (type) &#123; case 320: return new BMW320(); case 523: return new BMW523(); default: break; &#125; return null;\t&#125;&#125;//顾客类public class Customer &#123;\tpublic static void main(String[] args) &#123; Factory factory = new Factory(); factory.createBMW(320); factory.createBMW(523);\t&#125;&#125; 2、工厂方法模式例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package method;/** * 工厂方法模式：生产多种型号宝马产品 * 缺点：如果要生产多个产品，此将不再适用 * 弥补：提出抽象工厂模式，特点如下 * 抽象工厂模式有多个抽象产品类，具体工厂类可以创建多个具体产品类的实例 *///产品类interface BMW&#123;\t&#125;class BMW320 implements BMW&#123;\tpublic BMW320() &#123; System.out.println(&quot;生产BMW320&quot;);\t&#125;&#125;class BMW523 implements BMW&#123;\tpublic BMW523() &#123; System.out.println(&quot;生产BMW523&quot;);\t&#125;&#125;//工厂类interface FactoryBMW&#123;\tpublic BMW createBWM();&#125;class FactoryBMW320 implements FactoryBMW&#123;\t@Override\tpublic BMW createBWM() &#123; //父类作为方法返回值实现多态 // TODO Auto-generated method stub return new BMW320(); //返回该工厂生产的产品\t&#125;\t&#125;class FactoryBMW523 implements FactoryBMW&#123;\t@Override\tpublic BMW createBWM() &#123; // TODO Auto-generated method stub return new BMW523();\t&#125;&#125;//客户类public class Customer &#123;\tpublic static void main(String[] args) &#123; //创建320型号宝马的工厂 FactoryBMW320 factoryBMW320 = new FactoryBMW320(); factoryBMW320.createBWM(); //创建523型号宝马的工厂 FactoryBMW523 factoryBMW523 = new FactoryBMW523(); factoryBMW523.createBWM();\t&#125;&#125; 3、抽象工厂模式例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package ecjtu.mjh.abstr;/** * 抽象工厂模式:生产汽车的多种配件的多种型号产品 * 两个重要概念： * 产品等级结构：产品的继承结构。 * 产品族：在抽象工厂模式中，产品族（Dough、Sauce）是指由同一个工厂生产的， * 位于不同产品等级结构中的一组产品。 *///产品类//产品1：引擎interface Engine&#123;\t&#125;class EngineA implements Engine&#123;\tpublic EngineA() &#123; System.out.println(&quot;生产引擎A&quot;);\t&#125;&#125;class EngineB implements Engine&#123;\tpublic EngineB() &#123; System.out.println(&quot;生产引擎B&quot;);\t&#125;&#125;//产品2：轮胎interface Tyre&#123;\t&#125;class TyreA implements Tyre&#123;\tpublic TyreA() &#123; System.out.println(&quot;生产轮胎A&quot;);\t&#125;&#125;class TyreB implements Tyre&#123;\tpublic TyreB() &#123; System.out.println(&quot;生产轮胎B&quot;);\t&#125;&#125;//工厂类//抽象工厂接口interface AbstractFactory&#123;\tpublic Engine createEngine();\tpublic Tyre createTyre();&#125;class FactoryBMW320 implements AbstractFactory&#123; //生产宝马320系列配件的工厂：需要引擎A和轮胎A\t@Override\tpublic Engine createEngine() &#123; // TODO Auto-generated method stub return new EngineA();\t&#125;\t@Override\tpublic Tyre createTyre() &#123; // TODO Auto-generated method stub return new TyreA();\t&#125;\t&#125;class FactoryBMW523 implements AbstractFactory&#123; //生产宝马523系列配件的工厂：需要引擎B和轮胎B\t@Override\tpublic Engine createEngine() &#123; // TODO Auto-generated method stub return new EngineB();\t&#125;\t@Override\tpublic Tyre createTyre() &#123; // TODO Auto-generated method stub return new TyreB();\t&#125;\t&#125;public class Customer &#123;\tpublic static void main(String[] args) &#123; //要生产宝马320的配件的工厂 FactoryBMW320 f320 = new FactoryBMW320(); f320.createEngine(); f320.createTyre(); //要生产宝马523的配件的工厂 FactoryBMW523 f523 = new FactoryBMW523(); f523.createEngine(); f523.createTyre();\t&#125;&#125; 工厂方法模式与抽象工厂模式的区别 结合了上面的例子，看下面的区别就容易理解了 1）工厂方法模式： 一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类只能创建一个具体产品类的实例。 2）抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例。 3）两者区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。 适用场景和相互转换 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。 明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 总结 在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。解耦简单说就是让设计依赖于抽象（接口），而不是依赖于实现（具体的类）。打个比方，汽车制造者可以依赖于轮胎这个抽象的东西，但不能依赖于具体的品牌比如” 朝阳轮胎”。","tags":["java","设计模式"],"categories":["编程"]},{"title":"设计模式-单例模式 (Singleton Pattern)","path":"/2023/06/05/设计模式-单例模式 (Singleton Pattern)/","content":"单例模式通俗的解释就是一个类只有唯一的对象实例，那要怎么才能实现这一点呢？首先要知道所以的单例模式都是用静态方式实现的，单例对象实例都是存储在静态共享区。好了，知道了这些，下面就介绍具体是怎么实现的。 实现方法 一般要做这三件事！ 1、构造函数私有化（防止使用 new() 方法创建出多个对象实例） 2、进行初始化生成一个静态的对象实例（在不同时间生成，就产生了不同的写法） 3、提供 getInstance() 方法，返回一个生成的那个对象实例（方法名可以自己定义，只是习惯写成 getInstance） 常见类型 第一种：饿汉式（在类加载时就完成了初始化） 第二种：懒汉式（在类加载时不初始化而是在 getInstance() 方法中判断对象是否为 null，为空才初始化） 第三种：静态内部类（在静态内部类中，初始化对象实例） 代码实现1、饿汉式（推荐）123456789101112131415161718192021package test;/** * 饿汉式 * 线程是安全的 */public class SingleInstance &#123;\t//在类加载时就完成了初始化，final使对象实例不能改变（可写可不写，推荐写,javaApi里的单例也用了这个关键字）\t//final(保证对象的安全发布，防止对象引用被其他线程在对象被完全构造完成前拿到并使用)\tprivate static final SingleInstance INSTANCE = new SingleInstance();\tprivate SingleInstance() &#123;&#125; //构造函数私有化 private static SingleInstance getInstance() &#123; //获取对象的方法 return INSTANCE;\t&#125; public static void main(String[] args) &#123; SingleInstance test1 = SingleInstance.getInstance(); SingleInstance test2 = SingleInstance.getInstance(); System.out.println(test1 == test2);\t&#125;&#125; 2、懒汉式（不推荐）1234567891011121314151617181920212223package test;/** * 懒汉式 * 线程不安全型 */public class SingleInstance &#123;\t//在类加载时，只进行声明，不进行初始化，不能写final，因为后面要赋值修改\tprivate static SingleInstance INSTANCE;\tprivate SingleInstance() &#123;&#125; //构造函数私有化 private static SingleInstance getInstance() &#123; //获取对象的方法 if(INSTANCE == null) &#123; INSTANCE = new SingleInstance(); &#125; return INSTANCE;\t&#125; public static void main(String[] args) &#123; SingleInstance test1 = SingleInstance.getInstance(); SingleInstance test2 = SingleInstance.getInstance(); System.out.println(test1 == test2);\t&#125;&#125; 上面写法在多线程需要同步的环境下不能正常工作，那把它改为线程安全型的。 改为线程安全型的懒汉式，只需要在 getInstance() 方法前加上同步锁关键字 synchronized 即可，但加了同步锁之后，效率会变得很低，毕竟大多数情况下不需要同步的。所以推荐大家使用第一种方式。 3、静态内部类1234567891011121314151617181920212223package test;/** * 静态内部类 * 资源利用率高 */public class SingleInstance &#123;\t//在静态内部类中，初始化对象实例，相比饿汉式，不执行getInstance()就不会被实例，节省资源\tprivate static class SingletonHelp&#123; static final SingleInstance instance = new SingleInstance();\t&#125;\tprivate SingleInstance() &#123;&#125; //构造函数私有化 private static SingleInstance getInstance() &#123; //获取对象的方法 return SingletonHelp.instance;\t&#125; public static void main(String[] args) &#123; SingleInstance test1 = SingleInstance.getInstance(); SingleInstance test2 = SingleInstance.getInstance(); System.out.println(test1 == test2);\t&#125;&#125; 总结 对象的创建比较消耗资源，只需要一个时，比如资源共享的情况下，就可以使用单例模式，这样可以避免由于资源操作时导致的性能或损耗等。 再次说明，一般采用饿汉式，如果对资源要求利用率高，可以采用静态内部类，不建议采用懒汉式。","tags":["java","设计模式"],"categories":["编程"]},{"title":"算法的优劣评判","path":"/2023/06/04/算法的优劣评判/","content":"程序 &#x3D; 数据结构 + 算法，同一问题可用不同算法解决，一个好的算法能够使程序运行变得更高效，可能你在编程为了解决某一类问题，经常会用到算法，但你知道这个算法的效率怎么样吗？有没有比它效率还高的算法呢？所以今天我就想跟大家分享一下如何判断一个算法的好坏。 五大评判条件 1、时间复杂度 2、空间复杂度 3、正确性（要能使程序正确运行） 4、可读性（供人阅读的容易程度） 5、健壮性（算法对不合理数据输入的反应能力和处理能力，即容错性） 我们主要是根据时间复杂度和空间复杂度来比较算法的好坏。 算法复杂度时间复杂度1、理解： 它是指运行算法需要的计算工作量，是一个函数，描述了该算法的运行时间，时间复杂度常用大 O 符号表示。 2、计算方法： 第一步：定义符号 n：表示问题规模 T(n)：表示重复执行的次数，定义域是 n，T(n) 是 n 的一个函数。 f(n)：表示一个与 T(n) 同数量级的辅助函数 第二步：考察当输入值大小趋近无穷 当 n 趋近于无穷大时，T(n)&#x2F;f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数，记作 T(n)&#x3D;O(f(n)) 其中 O(f(n)) 为算法的渐进时间复杂度，简称就是时间复杂度。可以看出，主要就是要求得 f(n) 就行。 随着规模 n 的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，f(n) 越小，时间复杂度越低。 3、例子 上面做法就是，先算出基础操作的次数，然后再找出它的同数量级，最后比一下为常数。栗子如下： 12345678910int sum = 0;for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; s = i;//基本操作执行次数：n^2 for(int k = 0; k &lt; n; k++)&#123; s += j + k;//基本操作执行次数：n^3 &#125; &#125; &#125; 总次数为 T（n）&#x3D; n^2 + n^3，同数量级的一般取数量级高的 n^3，最后 T(n)&#x2F;f(n) &#x3D; 1&#x2F;n + 1，当 n 趋近无穷时，T(n)&#x2F;f(n) &#x3D; 1，为一个常数，所以时间复杂度为 O(n^3) 口算的计算方法是：看看有几重 for 循环，只有一重则时间复杂度为 O(n)，二重则为 O(n^2)，依此类推，如果有二分则为 O(logn)，二分例如二分查找，如果一个 for 循环套一个二分，那么时间复杂度则为 O(nlogn)。 空间复杂度1、理解： 它是指运行算法需要消耗的内存空间，详见百科空间复杂度。 2、时间复杂度函数 O(1)：表示为一个常量，即不随被处理数据量 n 的大小而改变。 O(log2n)：表示一个算法的空间复杂度与以 2 为底的 n 的对数成正比。 O(n)：表示一个算法的空间复杂度与 n 成线性比例关系。 等等, 以此类推…… 时间复杂度与空间复杂度的关系 时间复杂度和空间复杂度往往是相互影响，一个好另一个坏，反之。所以我们常会结合实际的需求来选择牺牲某一个换取另一个。 总结 选择一个高效的算法，主要是看时间复杂度和空间复杂度，当两者不能同时达到最优时，我们应该根据实际软件的要求，有舍有得，达到在时间上的高效利用或空间上的高效利用。","tags":["算法"],"categories":["编程"]},{"title":"介绍一些计算机语言","path":"/2023/06/03/介绍一些计算机语言/","content":"非编程语言HTML（超文本标记语言） HTML 是一种用于创建网页的标准标记语言。 HTML 是一种基础技术，常与 CSS、JavaScript 一起被众多网站用于设计令人赏心悦目的网页、网页应用程序以及移动应用程序的用户界面。HTML 描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言。 学习参考网站：W3school html5 教程 CSS（层叠样式表） CSS是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式的样式表语言。也属于计算机语言但非编程语言。 学习参考网站：W3school CSS 教程 编程语言Java Java 是一种计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级 Web 应用开发和移动应用开发。 编程范型：面向对象、结构化、命令式、泛型、反射、并发计算 语言类型：静态、安全、强类型、标明类型（静态类型语言的类型判断是在运行前判断（如编译阶段），动态类型语言，意思就是类型的检查是在运行时做的） Java 编程语言的风格十分接近 C++ 语言。继承了 C++ 语言面向对象技术的核心，Java 舍弃了 C++ 语言中容易引起错误的指针，改以引用取代，同时移除了 C++ 中的运算符重载和多重继承特性，改用接口取代，增加垃圾回收器功能。在 Java SE 1.5 版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装 &#x2F; 拆箱特性。 Java 不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，然后依赖各种不同平台上的虚拟机来解释执行字节码，从而实现了 “一次编写，到处运行” 的跨平台特性。 Java 语言最大的三个特点：面向对象，跨平台性，自动垃圾回收 C C 是一种计算机编程语言，广泛用于系统软件与应用软件的开发。 编程范型：指令式编程，面向过程、结构化编程 C 语言具有高效、灵活、功能丰富、表达力强和较高的可移植性等特点。 C++ C++ 是一种计算机编程语言。这种语言被称作 “C with Classes”（“包含‘类’的 C 语言”），作为 C 语言的增强版出现。C++ 是混合型面向对象程序设计语言, 继承并改进了 C 语言, 是一种既支持面向对象又支持面向过程的程序设计语言。 编程范型：面向对象编程，程序编程，泛型编程 语言类型：静态类型，强类型，不安全 C++ 设计成直接的和广泛的支持多种程序设计风格（过程化程序设计、数据抽象、面向对象编程、泛型程序设计） C++ 设计成尽可能与 C 兼容 C++ 不使用会带来额外开销的特性。 C++ 与 C 的代码执行效率往往相差在 ±5% 之间。 Python Python 是一种计算机编程语言，是一种解释型语言（Python 解释器解释运行，跨平台），它的设计强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词） 编程范型：多泛型、面向对象、指令式编程、函数式编程、程序编程 (过程式编程)、面向切面编程 语言类型：”duck”、动态类型、强类型 与 Scheme、Ruby、Perl、Tcl 等动态类型编程语言一样，Python 拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。 JavaScript JavaScript 是一种计算机编程语言，通过解释执行，是一门动态类型，面向对象（基于原型）的解释性语言（直译语言）。它提供语法来操控文本、数组、日期以及正则表达式等，但不支持 I&#x2F;O。 编程范型：(客户端) 脚本语言，面向对象（基于原型），指令式，函数式（函数式编程关心数据的映射，命令式编程关心解决问题的步骤） 语言类型：动态类型、弱类型、duck（鸭子类型，是动态类型的一种风格，关注点在于对象的行为，能作什么；而不是关注对象所属的类型，它的一个函数可以接受一个任意类型的对象，并调用它的方法，如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的方法的对象都可被函数接受） 动态化：和大部分脚本语言一样，类型与值而不是与变量关联。例如 x 变量可以为数值，随后又可被赋值为字符串。JavaScript 提供了包括鸭子类型在内的方法来检测变量类型。 它支持许多结构化编程语法（例如 if 条件语句、while 循环、switch 语句、do-while 循环等），它支持函数作用域 (var) 又支持块级作用域(let)。JavaScript 支持自动在语句末添加分号，但建议要在语句末尾加上分号。 PHP(超文本预处理器) PHP 是一种计算机编程语言，一种通用的服务器端脚本语言，尤其适用于网络开发并可嵌入 HTML 中使用。PHP 的语法借鉴吸收 C 语言、Java 和 Perl 等流行计算机语言的特点。PHP 的主要目标是允许网络开发人员快速编写动态页面，但 PHP 也被用于其他很多领域。 编程范型：(服务器端) 脚本语言、面向对象、指令式编程 语言类型：动态类型、弱类型 (为变量赋值时会自动判断类型并进行转换) PHP 可以用三种注解的形式：C 与 C++ 所使用的 “&#x2F;…&#x2F;” 与 “&#x2F;&#x2F;”，和 Perl 的 “#”。 PHP 主要有八种基本数据类型： 四种变量类型：整数型（integer），浮点数型（float），布尔型（boolean），字符串（string） 两种复合类型：数组（array），对象（object） 两种特殊类型：NULL，资源 （resource） PHP 中，变量以 “$” 后接变量名称来表示。 变量名称区分大小写（函数名不区分大小写）。有效的变量名称以字母或下划线开头，后接任意数目的字母、数字或下划线，PHP 也支持使用多字节文字作为变量名。（就是 C 语言的多字节字符，西方文字就是一个字节表示一个字符，如 ASCII 字符集。而东亚一些国家的文字，很多都是多个字节表示一个字符，如中文、韩文、日文等） 学习参考网站：PHP 手册","tags":["java","html","css","c","c++","python","JavaScript","php"],"categories":["编程"]},{"path":"/html/choice.html","content":"真心话大冒险 #input_m { outline-style: none; border: 1px solid #ccc; border-radius: 3px; padding: 13px 14px; width: 220px; font-size: 14px; font-weight: 600; font-family: 黑体, sans-serif; } #input_m:focus, #textarea_m:focus { border-color: #66afe9; outline: 0; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6) } .button_css_m { background: #eb94d0; /* 创建渐变 */ background-image: -webkit-linear-gradient(top, #eb94d0, #2079b0); background-image: -moz-linear-gradient(top, #eb94d0, #2079b0); background-image: -ms-linear-gradient(top, #eb94d0, #2079b0); background-image: -o-linear-gradient(top, #eb94d0, #2079b0); background-image: linear-gradient(to bottom, #eb94d0, #2079b0); /* 给按钮添加圆角 */ -webkit-border-radius: 18px; -moz-border-radius: 18px; border-radius: 18px; font-family: 黑体, sans-serif; font-weight: 600; color: #fafafa; font-size: 14px; padding: 6px; text-decoration: none; } /* 悬停样式 */ .button_css_m:hover { background: #2079b0; background-image: -webkit-linear-gradient(top, #2079b0, #eb94d0); background-image: -moz-linear-gradient(top, #2079b0, #eb94d0); background-image: -ms-linear-gradient(top, #2079b0, #eb94d0); background-image: -o-linear-gradient(top, #2079b0, #eb94d0); background-image: linear-gradient(to bottom, #2079b0, #eb94d0); text-decoration: none; } #textarea_m { overflow: scroll; width: 316px; height: 50px; resize: none; font-size: 14px; font-weight: 600; font-family: 黑体, sans-serif; } /* 滚动条的宽度设置为 10px */ ::-webkit-scrollbar { width: 10px; } ::-webkit-scrollbar-thumb { background-color: #888; } 真心话大冒险 谁是天选之人？ 试试 请选择接受一项惩罚： 真心话&nbsp;&nbsp;大冒险 设置真心话&nbsp;&nbsp;设置大冒险 let zxh_text = [\"1、近一个星期内最让你开心的事。\", \"2、最害怕的三件事物。\", \"3、和异性发生过最暧昧的事情。\", \"4、给你一个机会穿越到过去或未来，你选哪一个？为什么？\", \"5、如果让你形容自己会用哪三个词语？\", \"6、认为自己和哪种动物最相近？为什么？\", \"7、童年最有趣的一次经历。\", \"8、面对和他人产生的矛盾，你会怎么办？\", \"9、爱情事业和家庭，你怎么排序？\", \"10、最喜欢的三种食物或饮品。\"]; let dmx_text = [\"1、背一位异性绕场地3圈。\", \"2、唱《青藏高原》最后一句。\", \"3、做一个大家都满意的鬼脸。\", \"4、公主抱一位异性深蹲5次。\", \"5、跟一位异性真诚表白。\", \"6、与一位异性对视15秒。\", \"7、邀请一位异性为你唱情歌，或邀请一位异性与你情歌对唱。\", \"8、做自己最性感、最妩媚的表情或动作。\", \"9、做20个俯卧撑，女生的话就指定一位男生做。\", \"10、深情的吻墙10秒。\"]; function new_text(place_holder, btn_text, id) { let flag; if (btn_text === \"设置真心话\") { flag = \"520\"; } else if (btn_text === \"设置大冒险\") { flag = \"1314\"; } let zxh_btn = document.getElementById(\"set_zxh\"); let dmx_btn = document.getElementById(\"set_dmx\"); let btn = document.getElementById(id); let new_label = document.getElementById(\"label_text_m\"); let text_area = document.getElementById(\"textarea_m\"); let bt = btn.innerText; console.log(bt); if (bt === btn_text) { btn.innerText = \"确定\"; new_label.hidden = false; text_area.placeholder = place_holder; if (id === 'set_zxh') { dmx_btn.innerText = \"设置大冒险\"; } else if (id === 'set_dmx') { zxh_btn.innerText = \"设置真心话\"; } } else { if (text_area.value.length !== 0) { console.log(text_area.value); if (flag === \"520\") { zxh_text = arr_not_empty(text_area.value.split(\" \")); console.log(zxh_text); alert(\"自定义真心话成功！可以点击真心话随机抽取了一条了。\"); } else if (flag === \"1314\") { dmx_text = arr_not_empty(text_area.value.split(\" \")); console.log(dmx_text); alert(\"自定义大冒险成功！可以点击大冒险随机抽取了一条了。\"); } new_label.hidden = true; btn.innerText = btn_text; } } } function randomNum(min, max) { return Math.floor(Math.random() * (max - min) + min); } function randomColor() { let color_char = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F'] let color_arr = []; for (let i = 0; i < 6; i++) { color_arr[i] = randomNum(0, 16); } let color = \"#\"; for (const k in color_arr) { color = color + color_char[color_arr[k]]; } console.log(color); return color; } function arr_not_empty(arr) { let a = []; for (const k in arr) { if (arr[k].length !== 0) { a.push(arr[k]); } } return a; } function random() { let input = document.getElementById(\"input_m\"); let try_m = document.getElementById(\"try_m\"); let cf_result = document.getElementById(\"penalize_result_m\"); let arr = input.value.split(' '); let arr1 = arr_not_empty(arr); if (arr1.length === 0) { return; } let r1 = randomNum(0, arr1.length); let select = document.getElementById(\"people_m\"); select.innerText = arr1.toString().replaceAll(',', ' '); select.style.fontSize = \"18px\"; select.style.color = \"green\"; select.style.fontFamily = \"黑体\"; let result = document.getElementById(\"result_m\"); result.innerText = arr1[r1]; result.style.color = randomColor(); result.style.fontSize = \"52px\"; try_m.innerText = \"再试试\"; if (!cf_result.hidden) { cf_result.hidden = true; } document.getElementById(\"penalize_m\").hidden = false; } function penalize(arr) { let cf = randomNum(0, arr.length); let cf_result = document.getElementById(\"penalize_result_m\"); cf_result.hidden = false; cf_result.innerText = arr[cf]; cf_result.style.color = randomColor(); cf_result.style.fontSize = \"20px\"; }"},{"path":"/html/probability.html","content":"概率测试 .label_css_m { display: inline-block; color: tomato; } .label_css_m:before { content: '❌'; border: solid; border-radius: 3px; padding: 0.15em; } #on_off_m:checked + .label_css_m { color: turquoise; } #on_off_m:checked + .label_css_m:before { content: '✔'; } [type = \"checkbox\"] { position: fixed; left: -9999px; } #chance { outline-style: none; border: 1px solid #ccc; border-radius: 3px; padding: 13px 14px; width: 220px; font-size: 14px; font-weight: 600; font-family: 黑体, sans-serif; } #chance:focus { border-color: #66afe9; outline: 0; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6) } #btn_m { width: 42px; height: 42px; } 中奖概率测试 在输入框输入中奖概率数字，比如20.5，代表有20.5%的可能中奖，然后点击试试，可以多次尝试。 设置中奖概率（%）： 试试&nbsp;&nbsp; 中奖提示开关 你设置的中奖率为：% let total = 0, success = 0; function count() { let i = document.getElementById(\"chance\"); if (i.value.length === 0) { return; } let num1 = parseInt(i.value); if (isNaN(num1)) { alert(\"请输入数字！\") return; } if (num1 < 0 || num1 > 100) { alert(\"请输入0到100间的概率数值！\") return; } let l = document.getElementById(\"l\"); let n = document.getElementById(\"num\"); let v = document.getElementById(\"val\"); let l1 = document.getElementById(\"l1\"); let on_off = document.getElementById(\"on_off_m\"); total++; let random_num = Math.random() * 100; console.log(random_num); if (random_num < i.value) { //命中 l.innerText = \"中奖了\"; success++; if (on_off.checked) { alert(\"当前抽到\" + total + \"次了，恭喜你，中奖了！\"); } } else { //未命中 l.innerText = \"没中\"; } l.style.color = randomColor(); l.style.fontSize = \"50px\"; l1.hidden = false; v.innerText = i.value; v.style.color = \"red\"; v.style.fontSize = \"20px\"; n.innerText = \"抽了\" + total + \"次，中了\" + success + \"次，你的实际中奖率为：\" + success / total * 100 + \"%\"; } function randomColor() { let color_char = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F'] let color_arr = []; for (let i = 0; i < 6; i++) { color_arr[i] = randomNum(0, 16); } let color = \"#\"; for (const k in color_arr) { color = color + color_char[color_arr[k]]; } return color; } function randomNum(min, max) { return Math.floor(Math.random() * (max - min) + min); }"}]