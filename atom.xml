<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>M</title>
  
  <subtitle>阳光白梅 | Designed by mei</subtitle>
  <link href="https://meijhm.github.io/atom.xml" rel="self"/>
  
  <link href="https://meijhm.github.io/"/>
  <updated>2023-06-14T08:29:24.962Z</updated>
  <id>https://meijhm.github.io/</id>
  
  <author>
    <name>mjh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo+github搭博客</title>
    <link href="https://meijhm.github.io/2023/06/13/hexo+github%E6%90%AD%E5%8D%9A%E5%AE%A2/"/>
    <id>https://meijhm.github.io/2023/06/13/hexo+github%E6%90%AD%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-06-13T02:29:38.000Z</published>
    <updated>2023-06-14T08:29:24.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-github搭建博客网站"><a href="#hexo-github搭建博客网站" class="headerlink" title="hexo+github搭建博客网站"></a>hexo+github搭建博客网站</h2><h3 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a>官方教程</h3><p>  详细教程查看<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><h4 id="1、设置用户信息"><a href="#1、设置用户信息" class="headerlink" title="1、设置用户信息"></a>1、设置用户信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span> <span class="comment"># 用户名</span></span><br><span class="line">git config --global user.email  <span class="string">&quot;xxx@xxx.com&quot;</span> <span class="comment"># 邮箱</span></span><br></pre></td></tr></table></figure><h4 id="2、生成新的SSH-key"><a href="#2、生成新的SSH-key" class="headerlink" title="2、生成新的SSH key"></a>2、生成新的SSH key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮箱地址&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3、添加SSH-key到GitHub"><a href="#3、添加SSH-key到GitHub" class="headerlink" title="3、添加SSH key到GitHub"></a>3、添加SSH key到GitHub</h4><p>  登录GitHub，点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys<br>  然后把~.ssh\id_rsa.pub中的内容粘贴进去  </p><h4 id="4、github上建立仓库"><a href="#4、github上建立仓库" class="headerlink" title="4、github上建立仓库"></a>4、github上建立仓库</h4><p>  点New Repository，注意Repository名字是特定的，Github Pages Repository名字必须是账号名.github.io</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><p><a href="https://npm.taobao.org/mirrors/node/v10.16.3/">淘宝镜像下载压缩版的二进制文件zip包</a>  </p><h4 id="2、配置环境"><a href="#2、配置环境" class="headerlink" title="2、配置环境"></a>2、配置环境</h4><p>解压zip，在电脑系统环境中修改Path路径，添加在结尾添加;C:\Program Files\node-v10.16.3-win-x64<br><code>    Path=...;C:\Program Files\node-v10.16.3-win-x64;</code>  </p><h4 id="3、命令验证"><a href="#3、命令验证" class="headerlink" title="3、命令验证"></a>3、命令验证</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v  </span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h4 id="4、配置全局模块安装目录"><a href="#4、配置全局模块安装目录" class="headerlink" title="4、配置全局模块安装目录"></a>4、配置全局模块安装目录</h4><p>  可以配置全局模块安装目录，文件会保存至 「全局模块的安装目录node_modules」「缓存目录npm-cache」</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;C:\Program Files\node-v10.16.3-win-x64&quot;</span>  </span><br><span class="line">npm config <span class="built_in">set</span> cache <span class="string">&quot;C:\Program Files\node-v10.16.3-win-x64\npm-cache&quot;</span></span><br><span class="line">npm install xxx -g <span class="comment">#  全局安装xxx，可选参数 -g，g 代表 global，全局安装的意思</span></span><br></pre></td></tr></table></figure><h4 id="5、npm更换淘宝镜像"><a href="#5、npm更换淘宝镜像" class="headerlink" title="5、npm更换淘宝镜像"></a>5、npm更换淘宝镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><h4 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h4><p>  要在cmd管理员模式下进行安装，命令如下  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli <span class="comment"># 安装hexo</span></span><br><span class="line">hexo -v <span class="comment"># 查看版本</span></span><br></pre></td></tr></table></figure><h4 id="2、建立博客文件夹"><a href="#2、建立博客文件夹" class="headerlink" title="2、建立博客文件夹"></a>2、建立博客文件夹</h4><p>  自己建立一个文件夹放博客相关的文件，如mblog，下面命令对博客文件夹进行初始化  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> mblog</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h4 id="3、安装-Git-相关模块"><a href="#3、安装-Git-相关模块" class="headerlink" title="3、安装 Git 相关模块"></a>3、安装 Git 相关模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save <span class="comment"># 将文章部署到github上的模块</span></span><br><span class="line">npm install hexo-generator-feed --save <span class="comment"># 安装RSS插件</span></span><br><span class="line">npm install hexo-generator-sitemap --save <span class="comment"># 添加Sitemap,加速网页收录速度</span></span><br></pre></td></tr></table></figure><h4 id="4、配置远端地址"><a href="#4、配置远端地址" class="headerlink" title="4、配置远端地址"></a>4、配置远端地址</h4><p>编辑 _config.yml <strong>【：的后面是有一个空格的，不然后面会出错】</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">type: git  </span><br><span class="line">repository: git@github.com:test/test.github.io.git,master</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https://github.com/JiLuanxi/jiluanxi.github.io.git</span><br><span class="line">branch: </span><br><span class="line">message: </span><br><span class="line"></span><br><span class="line">//参数解释</span><br><span class="line">repo：直接复制 Repo 的URL即可</span><br><span class="line">branch：默认 push 到哪个分支。如果为空，则默认 push 到 master 分支</span><br><span class="line">message：默认提交信息。如果为空，则默认为 Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="5、使用hexo"><a href="#5、使用hexo" class="headerlink" title="5、使用hexo"></a>5、使用hexo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo s <span class="comment"># 在本地生成静态页面并预览</span></span><br></pre></td></tr></table></figure><h4 id="6、hexo主要目录"><a href="#6、hexo主要目录" class="headerlink" title="6、hexo主要目录"></a>6、hexo主要目录</h4><p>  _config.yml：整个站点的配置文件<br>  source&#x2F;_posts： 发表的博文目录<br>  source&#x2F;_drafts：彩稿文件目录<br>  themes：主题文件目录<br>  public：执行hexo g命令，输出的静态网页内容目录<br>  scaffolds：layout模板文件目录，其中的md文件可以添加编辑<br>  source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。</p><h4 id="7、主题"><a href="#7、主题" class="headerlink" title="7、主题"></a>7、主题</h4><p>  简洁美观：<a href="https://xaoxuu.com/wiki/stellar">https://xaoxuu.com/wiki/stellar</a></p><h4 id="8、常用命令"><a href="#8、常用命令" class="headerlink" title="8、常用命令"></a>8、常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n  <span class="comment"># == hexo new 建立新文章，默认在_posts下，layout=&quot;draft&quot;时发布的是草稿</span></span><br><span class="line">hexo p  <span class="comment"># == hexo publish 将_drafts下的文件放到_posts下，也就是发布草稿</span></span><br><span class="line">hexo g  <span class="comment"># == hexo generate 生成静态网页</span></span><br><span class="line">hexo s  <span class="comment"># == hexo server 启动预览服务器，开启-d选项时可以预览草稿</span></span><br><span class="line">hexo d  <span class="comment"># == hexo deploy 发布到远程服务器，开启--generate选项可以在deploy前自动generate</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">搭建属于自己的博客</summary>
    
    
    
    <category term="教程" scheme="https://meijhm.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="hexo" scheme="https://meijhm.github.io/tags/hexo/"/>
    
    <category term="博客" scheme="https://meijhm.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="github" scheme="https://meijhm.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>在线工具集</title>
    <link href="https://meijhm.github.io/2023/06/12/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <id>https://meijhm.github.io/2023/06/12/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%E9%9B%86/</id>
    <published>2023-06-11T16:00:00.000Z</published>
    <updated>2023-06-14T08:36:58.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="真心话大冒险"><a href="#真心话大冒险" class="headerlink" title="真心话大冒险"></a>真心话大冒险</h3><p>  这是一款真心话大冒险的现场多人游戏，可以和一群朋友一起玩耍。</p><p>  试试：<a href="https://meijhm.github.io/html/choice.html">真心话大冒险小游戏</a></p><h3 id="中奖模拟"><a href="#中奖模拟" class="headerlink" title="中奖模拟"></a>中奖模拟</h3><p>  这款工具可以自定义中奖率，精确到小数。欧皇就是我，体验一下万里挑一的感觉。</p><p>  试试：<a href="https://meijhm.github.io/html/choice.html">中奖模拟小游戏</a></p>]]></content>
    
    
    <summary type="html">有趣实用的在线小程序</summary>
    
    
    
    <category term="工具" scheme="https://meijhm.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="html" scheme="https://meijhm.github.io/tags/html/"/>
    
    <category term="在线工具" scheme="https://meijhm.github.io/tags/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
    
    <category term="多人小游戏" scheme="https://meijhm.github.io/tags/%E5%A4%9A%E4%BA%BA%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java、Tomcat和Mysql安装和配置</title>
    <link href="https://meijhm.github.io/2023/06/10/Java%E3%80%81Tomcat%E5%92%8CMysql%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>https://meijhm.github.io/2023/06/10/Java%E3%80%81Tomcat%E5%92%8CMysql%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</id>
    <published>2023-06-10T02:29:38.000Z</published>
    <updated>2023-06-14T07:27:04.357Z</updated>
    
    <content type="html"><![CDATA[<p>   Tomcat 和 Mysql 是解压版教程，Java要下载jdk安装。</p><h2 id="Java-环境变量配置"><a href="#Java-环境变量配置" class="headerlink" title="Java 环境变量配置"></a>Java 环境变量配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量名：【JAVA_HOME】  </span><br><span class="line">变量值：【D:\Program Files\Java\jdk1.8.0_92】（jdk 安装路径，替换为你自己的）</span><br><span class="line"></span><br><span class="line">变量名：【Path】  </span><br><span class="line">变量值：【;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; 】（加入 Path 中）</span><br><span class="line"></span><br><span class="line">变量名：【CLASSPATH】  </span><br><span class="line">变量值：【.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;】（. 不能漏）</span><br></pre></td></tr></table></figure><p>  这是很容易搞错的，在此记录。</p><h2 id="Tomcat-免安装版配置"><a href="#Tomcat-免安装版配置" class="headerlink" title="Tomcat 免安装版配置"></a>Tomcat 免安装版配置</h2><p>  如果之前安装注册了，打开管理员 cmd，运行 sc delete Tomcat9 （我的 Tomcat 的服务名为 Tomcat9，换成你自己的，一般换个版本号就行）</p><h3 id="环境变量配置："><a href="#环境变量配置：" class="headerlink" title="环境变量配置："></a>环境变量配置：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量名：【TOMCAT_HOME】  </span><br><span class="line">变量值：【D:\apache-tomcat-9.0.8】（Tomcat 解压路径，替换为你自己的，版本升级只需修改此处）</span><br><span class="line"></span><br><span class="line">变量名：【CATALINA_HOME】  </span><br><span class="line">变量值：【%TOMCAT_HOME%】</span><br><span class="line"></span><br><span class="line">变量名：【CATALINA_BASE】  </span><br><span class="line">变量值：【%TOMCAT_HOME%】</span><br></pre></td></tr></table></figure><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>  修改 D:\apache-tomcat-9.0.8\bin 下的 startup.bat 和 shutdown.bat 文件，首行加入下面两行：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET JAVA_HOME=C:\Program Files\Java\jdk1.8.0_60  </span><br><span class="line">SET CATALINA_HOME=D:\apache-tomcat-8.0.39  </span><br></pre></td></tr></table></figure><p>（替换为你自己的路径）</p><h3 id="注册-Tomcat-为-windows-系统服务"><a href="#注册-Tomcat-为-windows-系统服务" class="headerlink" title="注册 Tomcat 为 windows 系统服务"></a>注册 Tomcat 为 windows 系统服务</h3><p>  管理员的身份打开 windows 命令行，进入到 D:\apache-tomcat-9.0.8\bin 目录下，（不会自行百度），执行 service.bat install 命令，完成注册。配置完成。<br>  双击 bin 目录 tomcat9.exe 再点击运行，或在管理员命令行中用 net start Tomcat9 开启，用 net start Tomcat9 关闭。（Tomcat9 是服务名，一般换成自己的版本，实在不知道可以在 window 服务中查到名字）</p><h2 id="Mysql-免安装版配置"><a href="#Mysql-免安装版配置" class="headerlink" title="Mysql 免安装版配置"></a>Mysql 免安装版配置</h2><p>  如果之前安装注册了，打开管理员 cmd，运行 sc delete mysql</p><h3 id="环境变量配置：-1"><a href="#环境变量配置：-1" class="headerlink" title="环境变量配置："></a>环境变量配置：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名：【Path】  </span><br><span class="line">变量值：【D:\mysql-5.5.32\bin】（加入 Path 中，路径替换为你自己的）</span><br></pre></td></tr></table></figure><h3 id="新建-my-ini-文件"><a href="#新建-my-ini-文件" class="headerlink" title="新建 my.ini 文件"></a>新建 my.ini 文件</h3><p>  在 D:\mysql-5.5.32 目录下新建 my.ini 文件，内容为  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=D:\mysql-5.5.32\</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=D:\mysql-5.5.32\data</span><br><span class="line">#设置3306端口</span><br><span class="line">port=3306</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"># 服务端使用的字符集默认为八比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure><h3 id="注册-Mysql-为-windows-系统服务"><a href="#注册-Mysql-为-windows-系统服务" class="headerlink" title="注册 Mysql 为 windows 系统服务"></a>注册 Mysql 为 windows 系统服务</h3><p>  管理员的身份打开 windows 命令行，进入到 D:\mysql-5.5.32\bin 目录下，（不会自行百度）, 执行 mysqld install 命令，完成注册。</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net start mysql //启动服务。</span><br><span class="line">mysql -u root -p //登录root，默认无密码</span><br><span class="line">//登录后，修改密码：</span><br><span class="line">mysql&gt;use mysql;</span><br><span class="line">mysql&gt;update user set password=(&quot;123456&quot;) where user=&#x27;root&#x27;;</span><br><span class="line">mysql&gt;flush privileges;</span><br></pre></td></tr></table></figure><p>  配置完成了，类似上面启动，在管理员命令行中用 net start mysql 开启，用 net start mysql 关闭。（不用加版本号）</p>]]></content>
    
    
    <summary type="html">Windows下JavaWeb常用工具的安装和配置</summary>
    
    
    
    <category term="软件安装" scheme="https://meijhm.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="java" scheme="https://meijhm.github.io/tags/java/"/>
    
    <category term="tomcat" scheme="https://meijhm.github.io/tags/tomcat/"/>
    
    <category term="mysql" scheme="https://meijhm.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>ajax用法和json格式了解</title>
    <link href="https://meijhm.github.io/2023/06/09/ajax%E7%94%A8%E6%B3%95%E5%92%8Cjson%E6%A0%BC%E5%BC%8F%E4%BA%86%E8%A7%A3/"/>
    <id>https://meijhm.github.io/2023/06/09/ajax%E7%94%A8%E6%B3%95%E5%92%8Cjson%E6%A0%BC%E5%BC%8F%E4%BA%86%E8%A7%A3/</id>
    <published>2023-06-09T02:29:38.000Z</published>
    <updated>2023-06-14T07:22:31.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jQuery-调用-ajax-方法概述"><a href="#jQuery-调用-ajax-方法概述" class="headerlink" title="jQuery 调用 ajax 方法概述"></a>jQuery 调用 ajax 方法概述</h2><p>  ajax（异步 JavaScript 和 XML）：<br>  jQuery 可以通过 $.Ajax() 和 load(),$.get(),$.post(),$.getScript(),$.getJSON() 这些方法来使用 ajax。（注意下面提到的方法用，中括号括起来的参数，表示可选参数！）</p><h3 id="load-方法"><a href="#load-方法" class="headerlink" title="$.load() 方法"></a>$.load() 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#id&quot;).load(url, [data], [callback]);</span><br></pre></td></tr></table></figure><p>url: 要请求的页面地址<br>data：要发送到服务器的 key&#x2F;value 数据，没有指定传递方式默认为 get 方式<br>callback：请求完成时的回调函数（无论成败都调用），匿名函数定义如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function(responseText, textStates, XMLHttpRequest)&#123;</span><br><span class="line">//responseText：请求返回的内容</span><br><span class="line">   //textStates：请求状态：success   error  notmodified  timeout4种</span><br><span class="line">   //XMLHttpRequest：XMLHttpRequest对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="$.get() 方法"></a>$.get() 方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#btn&quot;).click(function()&#123;</span><br><span class="line">    $.get( url, [data], [callback], [type]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>url: 要请求的页面地址（可以用 php 页面处理后台数据）<br>data：要发送到服务器的 key&#x2F;value 数据，没有指定传递方式默认为 get 方式<br>callback：该回调函数只会在成功时调用，匿名函数定义如下  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function(data, textStatus)&#123;</span><br><span class="line">  //data：返回的内容，可以是XML文档，json文件，XHML片段等等</span><br><span class="line">  //textStatus：请求状态：success  error  notmodified timeout4种</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type：服务器返回数据的格式（有 json，xml，text，html，script）</p><h3 id="post-方法"><a href="#post-方法" class="headerlink" title="$.post() 方法"></a>$.post() 方法</h3><p>  $.post() 的用法和 $.get() 类似，不再累述，但我们要知道 get 和 post 两种方式传递数据的区别<br>  总结为四字口诀：数长可缓  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">          post                    get</span><br><span class="line">数据类型   文件和二进制文件         文本</span><br><span class="line">长度       无限                    255</span><br><span class="line">可见性     不可见                  可见</span><br><span class="line">缓存       无                      有</span><br></pre></td></tr></table></figure><h3 id="getScript-方法"><a href="#getScript-方法" class="headerlink" title="$.getScript( ) 方法"></a>$.getScript( ) 方法</h3><p>用于在需要的时候加载 JavaScript 文件  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.getScript(url, callback);</span><br></pre></td></tr></table></figure><p>url：请求地址 (一般是 js 文件，文件里写 js 处理问题的函数)<br>callback：回调匿名函数（必选参数）<br>一个小栗子：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;button&quot;).click(function()&#123;</span><br><span class="line">    $.getScript(&quot;hello.js&quot;, function() &#123;</span><br><span class="line">      alert(sayHello()); //调用hello.js中的sayHello()方法</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="getJson-方法"><a href="#getJson-方法" class="headerlink" title="$.getJson( ) 方法"></a>$.getJson( ) 方法</h3><p>用于在需要的时候加载 SON 文件  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(url, callback);</span><br></pre></td></tr></table></figure><p>url：请求地址<br>callback：回调匿名函数（必选参数），定义如下  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function(data)&#123; // 遍历json数据</span><br><span class="line">//1、$.each(data，function(index, value)&#123;//输出index索引，value变量或内容&#125;);</span><br><span class="line">//2、传统的for循环遍历</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ajax-方法"><a href="#Ajax-方法" class="headerlink" title="$.Ajax()方法"></a>$.Ajax()方法</h3><p>前面的方法都是基于此方法实现的，所以这个方法可以实现上面 4 个方法的所有功能。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;account.php&quot;, // 请求地址</span><br><span class="line">type: get, // &quot;get | post | put | delete &quot; 默认是get</span><br><span class="line">data: &#123;&quot;user&quot;:&quot;jack&quot;,&quot;pwd&quot;:&quot;1234&quot;&#125;, // 要发送到服务器的key/value数据</span><br><span class="line">dataType:&quot;text&quot;, // 请求数据类型（json，xml，text，html，script 和 jsonp ）</span><br><span class="line">success:function(data,dataTextStatus,jqxhr)&#123;</span><br><span class="line">    console.log(dataTextStatus);</span><br><span class="line">    console.log(jqxhr);</span><br><span class="line">    &#125;, // 请求成功时</span><br><span class="line">error:function(jqxhr,textStatus,error)&#123;</span><br><span class="line">    console.log(jqxhr);</span><br><span class="line">    console.log(textStatus);</span><br><span class="line">    &#125; // 请求失败时</span><br><span class="line">&#125;);</span><br><span class="line">//(6个参数，是用逗号隔开每个参数，最后可以不用逗号)</span><br></pre></td></tr></table></figure><h2 id="对-JavaScript-与-JSON-的了解"><a href="#对-JavaScript-与-JSON-的了解" class="headerlink" title="对 JavaScript 与 JSON 的了解"></a>对 JavaScript 与 JSON 的了解</h2><p>  描述 JSON 格式数据的语法采用了 JS 对象字面量的表示方法，但是不能把 JS 对象看做是 JSON，它们只是语法相似，和 XML 一样 JSON 只是一种存储数据的类型，不算编程语言。下面会具体对比它们。</p><h3 id="完整的-JavaScript-实现"><a href="#完整的-JavaScript-实现" class="headerlink" title="完整的 JavaScript 实现"></a>完整的 JavaScript 实现</h3><p>核心（ECMAScript）<br>文档对象模型（DOM）<br>浏览器对象模型（BOM）</p><h3 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><p>总共有六种类型，可以用 typeof 操作符检测类型，具体如下：<br>“undefined”——如果这个值未定义；<br>“boolean”——如果这个值是布尔值；<br>“string”——如果这个值是字符串；<br>“number”——如果这个值是数值；<br>“object”——如果这个值是对象或 null；<br>“function”——如果这个值是函数</p><h3 id="for-in-遍历"><a href="#for-in-遍历" class="headerlink" title="for-in 遍历"></a>for-in 遍历</h3><p>用来枚举对象的属性（注意：对象的属性没有顺序）  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (property in expression) statement</span><br></pre></td></tr></table></figure><p>小栗子：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function a(obj)&#123;</span><br><span class="line">if(obj != null || obj != undefined)&#123;</span><br><span class="line">for(var pro in obj)&#123;</span><br><span class="line">document.write(pro+&quot;&lt;br&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a(window); // 遍历window对象的所以属性</span><br></pre></td></tr></table></figure><h3 id="JSON-数据格式"><a href="#JSON-数据格式" class="headerlink" title="JSON 数据格式"></a>JSON 数据格式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>  JSON: JavaScript Object Notation（中文名：JavaScript 对象表示法），它和 JavaScript 对比如下：<br>1、JSON 中没有变量的概念，没有 (不用) 声明变量<br>2、没有末尾的分号<br>3、对象的属性必须加双引号</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>  与 JavaScript 对比：<br>1、简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。<br>但 JSON 不支持 JavaScript 中的特殊值 undefined。<br>2、对象 {}：是一组无序的键值对<br>3、数组 []：表示一组有序的值的列表<br>下面是一个栗子：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;age&quot;: 18,</span><br><span class="line">        &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">        &quot;school&quot;: &#123;</span><br><span class="line">            &quot;location&quot;: &quot;位置&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;一中&quot;,</span><br><span class="line">            &quot;teacher&quot;: [</span><br><span class="line">                &quot;老师一&quot;,</span><br><span class="line">                &quot;老师二&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;year&quot;: 2018</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;age&quot;: 18,</span><br><span class="line">        &quot;name&quot;: &quot;李四&quot;,</span><br><span class="line">        &quot;school&quot;: &#123;</span><br><span class="line">            &quot;location&quot;: &quot;位置&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;一中&quot;,</span><br><span class="line">            &quot;teacher&quot;: [</span><br><span class="line">                &quot;老师一&quot;,</span><br><span class="line">                &quot;老师二&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;year&quot;: 2017</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="JSON-对象的方法"><a href="#JSON-对象的方法" class="headerlink" title="JSON 对象的方法"></a>JSON 对象的方法</h4><p>  JSON 对象有两个方法：stringify() 和 parse()<br>1、把 JavaScript 对象序列化为 JSON 字符串（默认情况下，JSON.stringify() 输出的 JSON 字符串不包含任何空格字符或缩进）<br>2、把 JSON 字符串解析为原生 JavaScript 值</p><h4 id="JSON-与-XML-的写法对比"><a href="#JSON-与-XML-的写法对比" class="headerlink" title="JSON 与 XML 的写法对比"></a>JSON 与 XML 的写法对比</h4><p>json 栗子：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;employees&quot;:[</span><br><span class="line">    &#123;&quot;firstName&quot;:&quot;John&quot;, &quot;lastName&quot;:&quot;Doe&quot;&#125;,</span><br><span class="line">    &#123;&quot;firstName&quot;:&quot;Anna&quot;, &quot;lastName&quot;:&quot;Smith&quot;&#125;,</span><br><span class="line">    &#123;&quot;firstName&quot;:&quot;Peter&quot;, &quot;lastName&quot;:&quot;Jones&quot;&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>xml 栗子：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;employees&gt;</span><br><span class="line">    &lt;employee&gt;</span><br><span class="line">        &lt;firstName&gt;John&lt;/firstName&gt; &lt;lastName&gt;Doe&lt;/lastName&gt;</span><br><span class="line">    &lt;/employee&gt;</span><br><span class="line">    &lt;employee&gt;</span><br><span class="line">        &lt;firstName&gt;Anna&lt;/firstName&gt; &lt;lastName&gt;Smith&lt;/lastName&gt;</span><br><span class="line">    &lt;/employee&gt;</span><br><span class="line">    &lt;employee&gt;</span><br><span class="line">        &lt;firstName&gt;Peter&lt;/firstName&gt; &lt;lastName&gt;Jones&lt;/lastName&gt;</span><br><span class="line">    &lt;/employee&gt;</span><br><span class="line">&lt;/employees&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">jQuery调用ajax的用法介绍，简单了解json</summary>
    
    
    
    <category term="编程" scheme="https://meijhm.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="ajax" scheme="https://meijhm.github.io/tags/ajax/"/>
    
    <category term="json" scheme="https://meijhm.github.io/tags/json/"/>
    
    <category term="jquery" scheme="https://meijhm.github.io/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>Java简单图形编程</title>
    <link href="https://meijhm.github.io/2023/06/08/Java%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"/>
    <id>https://meijhm.github.io/2023/06/08/Java%E7%AE%80%E5%8D%95%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</id>
    <published>2023-06-08T02:29:38.000Z</published>
    <updated>2023-06-14T07:23:00.283Z</updated>
    
    <content type="html"><![CDATA[<p>  今天这篇博客，讲的是部分 Java GUI 图形界面的用法，在开发一些需要服务端和客户端进行通信时，我们常常会写个界面，这时候做 java 后台的可能对图形界面比较陌生，所以在此我要简单聊一聊常见图形界面布局的方法。主要讲<strong>网格布局</strong>和<strong>边界布局</strong>。</p><h2 id="Java-GUI-两个比较常用的布局方法"><a href="#Java-GUI-两个比较常用的布局方法" class="headerlink" title="Java GUI 两个比较常用的布局方法"></a>Java GUI 两个比较常用的布局方法</h2><h3 id="网格布局-GridLayout"><a href="#网格布局-GridLayout" class="headerlink" title="网格布局 (GridLayout)"></a>网格布局 (GridLayout)</h3><p>  先上代码，代码中有详细注释  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package gridlayout;</span><br><span class="line"></span><br><span class="line">import java.awt.GridLayout;</span><br><span class="line">import java.awt.event.ActionEvent;</span><br><span class="line">import java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line">import javax.swing.ButtonGroup;</span><br><span class="line">import javax.swing.JButton;</span><br><span class="line">import javax.swing.JCheckBox;</span><br><span class="line">import javax.swing.JFrame;</span><br><span class="line">import javax.swing.JLabel;</span><br><span class="line">import javax.swing.JOptionPane;</span><br><span class="line">import javax.swing.JPanel;</span><br><span class="line">import javax.swing.JPasswordField;</span><br><span class="line">import javax.swing.JRadioButton;</span><br><span class="line">import javax.swing.JTextField;</span><br><span class="line"></span><br><span class="line">public class Demo1 extends JFrame &#123;</span><br><span class="line">//定义个控件</span><br><span class="line">private JPanel[] ps = new JPanel[5]; //定义并分配了空间，没分配空间就操作会报空指针异常</span><br><span class="line">private JLabel l1, l2, l3, l4;</span><br><span class="line">private JTextField tf1;</span><br><span class="line">private JPasswordField pwf1;</span><br><span class="line">private JButton btn1, btn2;</span><br><span class="line">private JRadioButton rb1, rb2;</span><br><span class="line">private JCheckBox cb1, cb2;</span><br><span class="line">private ButtonGroup bg1, bg2;</span><br><span class="line"></span><br><span class="line">public Demo1() &#123;</span><br><span class="line">//初始化各控件</span><br><span class="line">for (int i = 0; i &lt; ps.length; i++) &#123;</span><br><span class="line">ps[i] = new JPanel();</span><br><span class="line">&#125;</span><br><span class="line">l1 = new JLabel(&quot;用户名：&quot;);</span><br><span class="line">l2 = new JLabel(&quot;密码：&quot;);</span><br><span class="line">l3 = new JLabel(&quot;性别：&quot;);</span><br><span class="line">l4 = new JLabel(&quot;爱好：&quot;);</span><br><span class="line">tf1 = new JTextField(15);</span><br><span class="line">pwf1 = new JPasswordField(15);</span><br><span class="line">btn1 = new JButton(&quot;登录&quot;);</span><br><span class="line">btn2 = new JButton(&quot;取消&quot;);</span><br><span class="line">rb1 = new JRadioButton(&quot;男&quot;);</span><br><span class="line">rb2 = new JRadioButton(&quot;女&quot;);</span><br><span class="line">bg1 = new ButtonGroup(); //使用单选按钮时，要使用ButtonGroup！复选按钮（框）不用！</span><br><span class="line">bg1.add(rb1);</span><br><span class="line">bg1.add(rb2);</span><br><span class="line">cb1 = new JCheckBox(&quot;唱歌&quot;);</span><br><span class="line">cb2 = new JCheckBox(&quot;跳舞&quot;);</span><br><span class="line"></span><br><span class="line">//设置布局，LayoutManager manager = new GridLayout(行rows，列cols);</span><br><span class="line">setLayout(new GridLayout(5, 1));</span><br><span class="line"></span><br><span class="line">//控件添加到面板Jpanel</span><br><span class="line">ps[0].add(l1);</span><br><span class="line">ps[0].add(tf1);</span><br><span class="line">ps[1].add(l2);</span><br><span class="line">ps[1].add(pwf1);</span><br><span class="line">ps[2].add(l3);</span><br><span class="line">ps[2].add(rb1); //注意：不能添加bg1，它算是对象的容器</span><br><span class="line">ps[2].add(rb2);</span><br><span class="line">ps[3].add(l4);</span><br><span class="line">ps[3].add(cb1);</span><br><span class="line">ps[3].add(cb2);</span><br><span class="line">ps[4].add(btn1);</span><br><span class="line">ps[4].add(btn2);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; ps.length; i++) &#123;</span><br><span class="line">add(ps[i]);//或写成this.add(ps[i]));原因见下</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用匿名内部类来监听事件源产生的事件</span><br><span class="line">btn2.addActionListener(new ActionListener() &#123;</span><br><span class="line">//实现ActionListener的actionPerformed方法</span><br><span class="line">@Override</span><br><span class="line">public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">JOptionPane.showMessageDialog(null, &quot;即将关闭&quot;); //弹出提示框</span><br><span class="line">dispose(); //dispose方法是关闭窗体，并释放一部分资源</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//设置JFrame窗体的各属性,(注：因为这些都是父类JFrame的方法，没有歧义时，我就省略了this，不想写一些多余的)</span><br><span class="line">setTitle(&quot;GridLayout测试&quot;);</span><br><span class="line">setSize(500, 400);</span><br><span class="line">setLocation(300, 100);</span><br><span class="line">setVisible(true); //设置窗体可见，不能忘了！</span><br><span class="line">//使用 System exit 方法退出应用程序。仅在应用程序中使用。如果不写，控制台会一直运行，不会退出</span><br><span class="line">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); </span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Demo1 demo1 = new Demo1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行效果图：  </p><div class="tag-plugin image"><div class="image-bg"><img src="https://cdn-us.imgs.moe/2023/06/14/6489192c29ad6.png"/></div></div> <p>  上面主要的思想是，每行可以放一个 JPanel 面板容器，里面又可以添加控件或容器，然后做成你想要的几行几列的网格布局。</p><h3 id="边界布局-BorderLayout"><a href="#边界布局-BorderLayout" class="headerlink" title="边界布局 (BorderLayout)"></a>边界布局 (BorderLayout)</h3><p>  1、布局方位：<br>  <div class="tag-plugin image"><div class="image-bg"><img src="https://cdn-us.imgs.moe/2023/06/14/6489192c281fb.jpg"/></div></div><br>  2、注意控件会自动调整：<br>  1）北和南位置控件各占上、下一行，控件宽度将自动布满整行。<br>  2）东、西和中间三个位置控件共占中间一行。<br>  3）东南西北四个位置，不管哪里缺了控件，中间的控件都会自动占据那里。<br>  具体效果大家可以自己去试试，下面看看我的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package borderlayout;</span><br><span class="line"></span><br><span class="line">import java.awt.BorderLayout;</span><br><span class="line">import javax.swing.JButton;</span><br><span class="line">import javax.swing.JComboBox;</span><br><span class="line">import javax.swing.JFrame;</span><br><span class="line">import javax.swing.JLabel;</span><br><span class="line">import javax.swing.JPanel;</span><br><span class="line">import javax.swing.JScrollPane;</span><br><span class="line">import javax.swing.JTextArea;</span><br><span class="line">import javax.swing.JTextField;</span><br><span class="line"></span><br><span class="line">public class Demo2 extends JFrame &#123;</span><br><span class="line">    private JLabel l1;</span><br><span class="line">    private JTextArea ta1;</span><br><span class="line">    private JScrollPane sp1;</span><br><span class="line">    private JComboBox&lt;String&gt; cb1;</span><br><span class="line">    private JTextField tf1;</span><br><span class="line">    private JButton btn1;</span><br><span class="line">    private JPanel p1;</span><br><span class="line"></span><br><span class="line">    public Demo2() &#123;</span><br><span class="line">        //初始化</span><br><span class="line">        l1 = new JLabel(&quot;聊天界面&quot;);</span><br><span class="line">        ta1 = new JTextArea(); //不写参数，会自动调节大小</span><br><span class="line">        sp1 = new JScrollPane(ta1);</span><br><span class="line">        String[] strs = &#123;&quot;非匿名&quot;, &quot;匿名&quot;&#125;;</span><br><span class="line">        cb1 = new JComboBox&lt;String&gt;(strs);</span><br><span class="line">        tf1 = new JTextField(15);</span><br><span class="line">        btn1 = new JButton(&quot;发送&quot;);</span><br><span class="line">        p1 = new JPanel();</span><br><span class="line"></span><br><span class="line">        p1.add(cb1);</span><br><span class="line">        p1.add(tf1);</span><br><span class="line">        p1.add(btn1);</span><br><span class="line"></span><br><span class="line">        add(l1, BorderLayout.NORTH);</span><br><span class="line">        add(sp1, BorderLayout.CENTER);</span><br><span class="line">        add(p1, BorderLayout.SOUTH);</span><br><span class="line"></span><br><span class="line">        setTitle(&quot;BorderLayout测试&quot;);</span><br><span class="line">        setSize(500, 400);</span><br><span class="line">        setLocation(300, 100);</span><br><span class="line">        setVisible(true);</span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); </span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo2 demo2 = new Demo2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  运行效果图：  </p><div class="tag-plugin image"><div class="image-bg"><img src="https://cdn-us.imgs.moe/2023/06/14/6489192c27d8b.png"/></div></div>  <p>  上面就是中间的控件自动占据了东、西俩位置，因为就东、西俩位置没控件。</p><h3 id="JOptionPane-消息提示框"><a href="#JOptionPane-消息提示框" class="headerlink" title="JOptionPane 消息提示框"></a>JOptionPane 消息提示框</h3><p>  因为我们在写界面时，可能会要弹出一些提示框，上面的第一个例子就用到了，在此我简单介绍一下三种消息常用的提示框方法（其实有四种，这三种比较常用和简单）：<br>  1、showConfirmDialog      询问确认问题，如是 &#x2F; 否 &#x2F; 取消。<br>  2、showInputDialog      提示输入一些内容。<br>  3、showMessageDialog      告诉用户发生了什么事。<br>  简单的用法就是这样：JOptionPane.showMessageDialog(null,” 要显示的文字”)，把 showMessageDialog 换成你想要的方法即可。如果想要详细学习 JOptionPane 的用法，可以参考<a href="https://docs.oracle.com/javase/tutorial/uiswing/components/dialog.html">官方文档</a>, 是英文的，英文不好的童鞋记得用下谷歌浏览器自带的翻译。好了图形界面的简单编程就讲到这，拜拜了！</p>]]></content>
    
    
    <summary type="html">Java GUI图形界面编程方法入门</summary>
    
    
    
    <category term="编程" scheme="https://meijhm.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://meijhm.github.io/tags/java/"/>
    
    <category term="JavaGUI" scheme="https://meijhm.github.io/tags/JavaGUI/"/>
    
  </entry>
  
  <entry>
    <title>java线程状态</title>
    <link href="https://meijhm.github.io/2023/06/07/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <id>https://meijhm.github.io/2023/06/07/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</id>
    <published>2023-06-07T02:29:38.000Z</published>
    <updated>2023-06-14T07:23:41.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><h4 id="1、新建状态-new"><a href="#1、新建状态-new" class="headerlink" title="1、新建状态 (new)"></a>1、新建状态 (new)</h4><p>  用 new 等方法创建了线程对象，但线程至今尚未启动。（下面说明怎么启动）  </p><h4 id="2、可运行状态-runnable"><a href="#2、可运行状态-runnable" class="headerlink" title="2、可运行状态 (runnable)"></a>2、可运行状态 (runnable)</h4><p>  创建线程对象后，其他线程(比如 main 线程）调用了该对象的 start() 方法启动。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权 。  </p><h4 id="3、运行状态-running"><a href="#3、运行状态-running" class="headerlink" title="3、运行状态 (running)"></a>3、运行状态 (running)</h4><p>  在可运行状态(runnable) 的基础上获得了 cpu 时间片（timeslice）的线程，称运行状态的线程，在这执行程序代码。  </p><h4 id="4、阻塞状态-block"><a href="#4、阻塞状态-block" class="headerlink" title="4、阻塞状态 (block)"></a>4、阻塞状态 (block)</h4><p>  阻塞状态是指线程因为某种原因放弃了 cpu 使用权，即让出了 cpu 时间片（timeslice），暂时停止运行。直到线程进入可运行(runnable) 状态，才有机会再次获得 cpu 时间片（timeslice）转到运行 (running) 状态。阻塞的情况分三种：<br>  (1)、 等待阻塞：运行 (running) 的线程执行 wait()方法，JVM 会把该线程放入等待队列 (waitting queue) 中。<br>  (2)、 同步阻塞：运行 (running) 的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池 (lock pool) 中。<br>  (3)、 其他阻塞：运行 (running) 的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I&#x2F;O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入可运行 (runnable) 状态。  </p><h4 id="5、死亡-dead"><a href="#5、死亡-dead" class="headerlink" title="5、死亡 (dead)"></a>5、死亡 (dead)</h4><p>  线程 run()、main() 方法执行结束，或者因异常退出了 run() 方法，则该线程结束生命周期。死亡的线程不可再次复生。</p><h3 id="线程的状态转换图"><a href="#线程的状态转换图" class="headerlink" title="线程的状态转换图"></a>线程的状态转换图</h3><div class="tag-plugin image"><div class="image-bg"><img src="https://cdn-us.imgs.moe/2023/06/14/6489146b482a5.png"/></div></div><h3 id="线程中一些方法的解释"><a href="#线程中一些方法的解释" class="headerlink" title="线程中一些方法的解释"></a>线程中一些方法的解释</h3><p>  Thread.yield()：暂停当前正在执行的线程对象，并执行其他线程。使有相同优先级的线程有机会执行。<br>  join()：（ 必须要在线程启动后才能使用）调用 join() 方法的线程将被优先执行，直到此线程运行结束，当前线程才能继续运行。 调用 join(long mills)方法的线程将被优先执行，直到此线程运行结束或者经过 mills 时间，当前线程才能继续运行。<br>  sleep()：  让线性休眠，必须指定时间，时间到了后，线程会自动醒来，在休眠的时候，不会释放锁的所有权，当休眠时间到后，会继续执行<br>  wait()：  让线程暂停，可以指定时间，也可以不指定，可以通过 notity、notityAll 释放锁的所有权。</p>]]></content>
    
    
    <summary type="html">Java线程的状态有哪些，状态间是怎样转换的</summary>
    
    
    
    <category term="编程" scheme="https://meijhm.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://meijhm.github.io/tags/java/"/>
    
    <category term="多线程" scheme="https://meijhm.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式 (Factory Pattern)</title>
    <link href="https://meijhm.github.io/2023/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%20(Factory%20Pattern)/"/>
    <id>https://meijhm.github.io/2023/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%20(Factory%20Pattern)/</id>
    <published>2023-06-06T02:29:38.000Z</published>
    <updated>2023-06-14T07:24:09.935Z</updated>
    
    <content type="html"><![CDATA[<p>  <a href="https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549?fr=aladdin">设计模式</a>中的工厂模式。它属于创建型模式，那么什么是创建行模式呢，它主要就是将类或者对象的实例化过程抽象起来，可以分为类的创建型模式和对象的创建型模式两类，而工厂模式就属于对象的创建型模式。  </p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>  工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。（通俗说就是工厂会根据不同的情况，为我们创建不同的产品。）</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>  1）简单工厂模式 - Simple Factory Pattern<br>  2）工厂方法模式 - Factory Method Pattern<br>  3）抽象工厂模式 - Abstract Factory Pattern</p><p>  这三种模式从上到下逐步抽象，并且一个比一个更具有一般性。<a href="https://baike.baidu.com/item/GoF/6406151">GoF</a> 在《设计模式》一书中，将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。所以也有人将工厂模式分为两类，在这我更偏向把它分为三类，后面分三类举例讲解。</p><h3 id="三种工厂模式用法"><a href="#三种工厂模式用法" class="headerlink" title="三种工厂模式用法"></a>三种工厂模式用法</h3><h4 id="1、简单工厂模式："><a href="#1、简单工厂模式：" class="headerlink" title="1、简单工厂模式："></a>1、简单工厂模式：</h4><p>  专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。它又称为静态工厂方法模式。它的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。</p><h4 id="2、工厂方法模式："><a href="#2、工厂方法模式：" class="headerlink" title="2、工厂方法模式："></a>2、工厂方法模式：</h4><p>  在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。有一个抽象的 Factory 类（可以是抽象类和接口），这个类将不在负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。</p><h4 id="3、抽象工厂模式："><a href="#3、抽象工厂模式：" class="headerlink" title="3、抽象工厂模式："></a>3、抽象工厂模式：</h4><p>  抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类， 可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。</p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>  看了上面的用法，大家可能有些不能理解，下面就用三个非常简单的栗子阐述清楚这些概念：  </p><h4 id="1、简单工厂模式例子"><a href="#1、简单工厂模式例子" class="headerlink" title="1、简单工厂模式例子"></a>1、简单工厂模式例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package simple;</span><br><span class="line">/**</span><br><span class="line"> * 简单工厂模式：生产多种型号宝马产品</span><br><span class="line"> * 补充：开闭原则——&gt;对扩展的开放，对修改的关闭</span><br><span class="line"> * 缺点：每增加一种新型车,工厂类中需要增加相应的case，违背开闭原则（对扩展的开发，对修改的关闭）</span><br><span class="line"> * 弥补：提出工厂方法模式，定义如下</span><br><span class="line"> * 工厂类定义成了接口,而每新增的车种类型,就增加该车种类型对应工厂类的实现,</span><br><span class="line"> * 这样工厂的设计就可以扩展了,而不必去修改原来的代码。</span><br><span class="line"> */</span><br><span class="line">//产品类</span><br><span class="line">interface BMW&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class BMW320 implements BMW&#123;</span><br><span class="line">public BMW320() &#123;</span><br><span class="line">System.out.println(&quot;制造 BMW320&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class BMW523 implements BMW&#123;</span><br><span class="line">public BMW523() &#123;</span><br><span class="line"> System.out.println(&quot;制造 BMW523&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//工厂类</span><br><span class="line">class Factory&#123;</span><br><span class="line">public BMW createBMW(int type) &#123; //根据参数不同，返回不同的产品（对象）</span><br><span class="line">switch (type) &#123;</span><br><span class="line">case 320:</span><br><span class="line">return new BMW320();</span><br><span class="line">case 523:</span><br><span class="line">return new BMW523();</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//顾客类</span><br><span class="line">public class Customer &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Factory factory = new Factory();</span><br><span class="line">factory.createBMW(320);</span><br><span class="line">factory.createBMW(523);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、工厂方法模式例子"><a href="#2、工厂方法模式例子" class="headerlink" title="2、工厂方法模式例子"></a>2、工厂方法模式例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package method;</span><br><span class="line">/**</span><br><span class="line"> * 工厂方法模式：生产多种型号宝马产品</span><br><span class="line"> * 缺点：如果要生产多个产品，此将不再适用</span><br><span class="line"> * 弥补：提出抽象工厂模式，特点如下</span><br><span class="line"> * 抽象工厂模式有多个抽象产品类，具体工厂类可以创建多个具体产品类的实例</span><br><span class="line"> */</span><br><span class="line">//产品类</span><br><span class="line">interface BMW&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class BMW320 implements BMW&#123;</span><br><span class="line">public BMW320() &#123;</span><br><span class="line">System.out.println(&quot;生产BMW320&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class BMW523 implements BMW&#123;</span><br><span class="line">public BMW523() &#123;</span><br><span class="line">System.out.println(&quot;生产BMW523&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//工厂类</span><br><span class="line">interface FactoryBMW&#123;</span><br><span class="line">public BMW createBWM();</span><br><span class="line">&#125;</span><br><span class="line">class FactoryBMW320 implements FactoryBMW&#123;</span><br><span class="line">@Override</span><br><span class="line">public BMW createBWM() &#123; //父类作为方法返回值实现多态</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new BMW320(); //返回该工厂生产的产品</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class FactoryBMW523 implements FactoryBMW&#123;</span><br><span class="line">@Override</span><br><span class="line">public BMW createBWM() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new BMW523();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户类</span><br><span class="line">public class Customer &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//创建320型号宝马的工厂</span><br><span class="line">FactoryBMW320 factoryBMW320 = new FactoryBMW320();</span><br><span class="line">factoryBMW320.createBWM();</span><br><span class="line">//创建523型号宝马的工厂</span><br><span class="line">FactoryBMW523 factoryBMW523 = new FactoryBMW523();</span><br><span class="line">factoryBMW523.createBWM();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、抽象工厂模式例子"><a href="#3、抽象工厂模式例子" class="headerlink" title="3、抽象工厂模式例子"></a>3、抽象工厂模式例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">package ecjtu.mjh.abstr;</span><br><span class="line">/**</span><br><span class="line"> * 抽象工厂模式:生产汽车的多种配件的多种型号产品</span><br><span class="line"> * 两个重要概念：</span><br><span class="line"> * 产品等级结构：产品的继承结构。</span><br><span class="line"> * 产品族：在抽象工厂模式中，产品族（Dough、Sauce）是指由同一个工厂生产的，</span><br><span class="line"> * 位于不同产品等级结构中的一组产品。</span><br><span class="line"> */</span><br><span class="line">//产品类</span><br><span class="line">//产品1：引擎</span><br><span class="line">interface Engine&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class EngineA implements Engine&#123;</span><br><span class="line">public EngineA() &#123;</span><br><span class="line">System.out.println(&quot;生产引擎A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class EngineB implements Engine&#123;</span><br><span class="line">public EngineB() &#123;</span><br><span class="line">System.out.println(&quot;生产引擎B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//产品2：轮胎</span><br><span class="line">interface Tyre&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class TyreA implements Tyre&#123;</span><br><span class="line">public TyreA() &#123;</span><br><span class="line">System.out.println(&quot;生产轮胎A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class TyreB implements Tyre&#123;</span><br><span class="line">public TyreB() &#123;</span><br><span class="line">System.out.println(&quot;生产轮胎B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//工厂类</span><br><span class="line">//抽象工厂接口</span><br><span class="line">interface AbstractFactory&#123;</span><br><span class="line">public Engine createEngine();</span><br><span class="line">public Tyre createTyre();</span><br><span class="line">&#125;</span><br><span class="line">class FactoryBMW320 implements AbstractFactory&#123; </span><br><span class="line">    //生产宝马320系列配件的工厂：需要引擎A和轮胎A</span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new EngineA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new TyreA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class FactoryBMW523 implements AbstractFactory&#123; </span><br><span class="line">    //生产宝马523系列配件的工厂：需要引擎B和轮胎B</span><br><span class="line">@Override</span><br><span class="line">public Engine createEngine() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new EngineB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Tyre createTyre() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return new TyreB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Customer &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//要生产宝马320的配件的工厂</span><br><span class="line">FactoryBMW320 f320 = new FactoryBMW320();</span><br><span class="line">f320.createEngine();</span><br><span class="line">f320.createTyre();</span><br><span class="line"></span><br><span class="line">//要生产宝马523的配件的工厂</span><br><span class="line">FactoryBMW523 f523 = new FactoryBMW523();</span><br><span class="line">f523.createEngine();</span><br><span class="line">f523.createTyre();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式与抽象工厂模式的区别"><a href="#工厂方法模式与抽象工厂模式的区别" class="headerlink" title="工厂方法模式与抽象工厂模式的区别"></a>工厂方法模式与抽象工厂模式的区别</h3><p>  结合了上面的例子，看下面的区别就容易理解了<br>  1）工厂方法模式：<br>  一个抽象产品类，可以派生出多个具体产品类。<br>  一个抽象工厂类，可以派生出多个具体工厂类。<br>  每个具体工厂类只能创建一个具体产品类的实例。<br>  2）抽象工厂模式：<br>  多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。<br>  一个抽象工厂类，可以派生出多个具体工厂类。<br>  每个具体工厂类可以创建多个具体产品类的实例。<br>  3）两者区别：<br>  工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。<br>  工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。</p><h3 id="适用场景和相互转换"><a href="#适用场景和相互转换" class="headerlink" title="适用场景和相互转换"></a>适用场景和相互转换</h3><p>  当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。<br>  明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。解耦简单说就是让设计依赖于抽象（接口），而不是依赖于实现（具体的类）。打个比方，汽车制造者可以依赖于轮胎这个抽象的东西，但不能依赖于具体的品牌比如” 朝阳轮胎”。</p>]]></content>
    
    
    <summary type="html">简单易懂的介绍设计模式之工厂模式</summary>
    
    
    
    <category term="编程" scheme="https://meijhm.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://meijhm.github.io/tags/java/"/>
    
    <category term="设计模式" scheme="https://meijhm.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式 (Singleton Pattern)</title>
    <link href="https://meijhm.github.io/2023/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20(Singleton%20Pattern)/"/>
    <id>https://meijhm.github.io/2023/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20(Singleton%20Pattern)/</id>
    <published>2023-06-05T02:29:38.000Z</published>
    <updated>2023-06-14T07:24:23.414Z</updated>
    
    <content type="html"><![CDATA[<p>  单例模式通俗的解释就是<strong>一个类只有唯一的对象实例</strong>，那要怎么才能实现这一点呢？首先要知道所以的单例模式都是用静态方式实现的，单例对象实例都是存储在静态共享区。好了，知道了这些，下面就介绍具体是怎么实现的。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>  一般要做这三件事！<br>  1、构造函数私有化（防止使用 new() 方法创建出多个对象实例）<br>  2、进行初始化生成一个静态的对象实例（在不同时间生成，就产生了不同的写法）<br>  3、提供 getInstance() 方法，返回一个生成的那个对象实例（方法名可以自己定义，只是习惯写成 getInstance）</p><h2 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h2><p>  第一种：饿汉式（在类加载时就完成了初始化）<br>  第二种：懒汉式（在类加载时不初始化而是在 getInstance() 方法中判断对象是否为 null，为空才初始化）<br>  第三种：静态内部类（在静态内部类中，初始化对象实例）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="1、饿汉式（推荐）"><a href="#1、饿汉式（推荐）" class="headerlink" title="1、饿汉式（推荐）"></a>1、饿汉式（推荐）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line">/**</span><br><span class="line"> * 饿汉式</span><br><span class="line"> * 线程是安全的</span><br><span class="line"> */</span><br><span class="line">public class SingleInstance &#123;</span><br><span class="line">//在类加载时就完成了初始化，final使对象实例不能改变（可写可不写，推荐写,javaApi里的单例也用了这个关键字）</span><br><span class="line">//final(保证对象的安全发布，防止对象引用被其他线程在对象被完全构造完成前拿到并使用)</span><br><span class="line">private static final SingleInstance INSTANCE = new SingleInstance();</span><br><span class="line">private SingleInstance() &#123;&#125; //构造函数私有化</span><br><span class="line"></span><br><span class="line">private static SingleInstance getInstance() &#123; //获取对象的方法</span><br><span class="line">return INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SingleInstance test1 = SingleInstance.getInstance();</span><br><span class="line">SingleInstance test2 = SingleInstance.getInstance();</span><br><span class="line">System.out.println(test1 == test2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、懒汉式（不推荐）"><a href="#2、懒汉式（不推荐）" class="headerlink" title="2、懒汉式（不推荐）"></a>2、懒汉式（不推荐）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line">/**</span><br><span class="line"> * 懒汉式</span><br><span class="line"> * 线程不安全型</span><br><span class="line"> */</span><br><span class="line">public class SingleInstance &#123;</span><br><span class="line">//在类加载时，只进行声明，不进行初始化，不能写final，因为后面要赋值修改</span><br><span class="line">private static SingleInstance INSTANCE;</span><br><span class="line">private SingleInstance() &#123;&#125; //构造函数私有化</span><br><span class="line"></span><br><span class="line">private static SingleInstance getInstance() &#123; //获取对象的方法</span><br><span class="line">if(INSTANCE == null) &#123;</span><br><span class="line">INSTANCE = new SingleInstance();</span><br><span class="line">&#125;</span><br><span class="line">return INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SingleInstance test1 = SingleInstance.getInstance();</span><br><span class="line">SingleInstance test2 = SingleInstance.getInstance();</span><br><span class="line">System.out.println(test1 == test2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  上面写法在多线程需要同步的环境下不能正常工作，那把它改为线程安全型的。<br>  改为线程安全型的懒汉式，只需要在 getInstance() 方法前加上同步锁关键字 synchronized 即可，但加了同步锁之后，效率会变得很低，毕竟大多数情况下不需要同步的。所以推荐大家使用第一种方式。  </p><h3 id="3、静态内部类"><a href="#3、静态内部类" class="headerlink" title="3、静态内部类"></a>3、静态内部类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line">/**</span><br><span class="line"> * 静态内部类</span><br><span class="line"> * 资源利用率高</span><br><span class="line"> */</span><br><span class="line">public class SingleInstance &#123;</span><br><span class="line">//在静态内部类中，初始化对象实例，相比饿汉式，不执行getInstance()就不会被实例，节省资源</span><br><span class="line">private static class SingletonHelp&#123;</span><br><span class="line">static final SingleInstance instance = new SingleInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private SingleInstance() &#123;&#125; //构造函数私有化</span><br><span class="line"></span><br><span class="line">private static SingleInstance getInstance() &#123; //获取对象的方法</span><br><span class="line">return SingletonHelp.instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SingleInstance test1 = SingleInstance.getInstance();</span><br><span class="line">SingleInstance test2 = SingleInstance.getInstance();</span><br><span class="line">System.out.println(test1 == test2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  对象的创建比较消耗资源，只需要一个时，比如资源共享的情况下，就可以使用单例模式，这样可以避免由于资源操作时导致的性能或损耗等。<br>  再次说明，一般采用饿汉式，如果对资源要求利用率高，可以采用静态内部类，不建议采用懒汉式。</p>]]></content>
    
    
    <summary type="html">单例模式的三种写法详细介绍</summary>
    
    
    
    <category term="编程" scheme="https://meijhm.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://meijhm.github.io/tags/java/"/>
    
    <category term="设计模式" scheme="https://meijhm.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法的优劣评判</title>
    <link href="https://meijhm.github.io/2023/06/04/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%A3%E8%AF%84%E5%88%A4/"/>
    <id>https://meijhm.github.io/2023/06/04/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%A3%E8%AF%84%E5%88%A4/</id>
    <published>2023-06-04T02:29:38.000Z</published>
    <updated>2023-06-14T07:24:38.654Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>程序 &#x3D; 数据结构 + 算法</strong>，同一问题可用不同算法解决，一个好的算法能够使程序运行变得更高效，可能你在编程为了解决某一类问题，经常会用到算法，但你知道这个算法的效率怎么样吗？有没有比它效率还高的算法呢？所以今天我就想跟大家分享一下如何判断一个算法的好坏。</p><h2 id="五大评判条件"><a href="#五大评判条件" class="headerlink" title="五大评判条件"></a>五大评判条件</h2><p>  1、时间复杂度<br>  2、空间复杂度<br>  3、正确性（要能使程序正确运行）<br>  4、可读性（供人阅读的容易程度）<br>  5、健壮性（算法对不合理数据输入的反应能力和处理能力，即容错性）<br>  我们主要是根据<strong>时间复杂度</strong>和<strong>空间复杂度</strong>来比较算法的好坏。</p><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h4 id="1、理解："><a href="#1、理解：" class="headerlink" title="1、理解："></a>1、理解：</h4><p>  它是指运行算法需要的计算工作量，是一个函数，描述了该算法的运行时间，时间复杂度常用大 O 符号表示。  </p><h4 id="2、计算方法："><a href="#2、计算方法：" class="headerlink" title="2、计算方法："></a>2、计算方法：</h4><p>  第一步：定义符号<br>  n：表示问题规模<br>  T(n)：表示重复执行的次数，定义域是 n，T(n) 是 n 的一个函数。<br>  f(n)：表示一个与 T(n) 同数量级的辅助函数</p><p>  第二步：考察当输入值大小趋近无穷<br>  当 n 趋近于无穷大时，T(n)&#x2F;f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数，记作 T(n)&#x3D;O(f(n))<br>  其中 O(f(n)) 为算法的渐进时间复杂度，简称就是时间复杂度。可以看出，主要就是要求得 f(n) 就行。<br>  随着规模 n 的增大，算法执行的时间的增长率和 f(n) 的增长率成正比，f(n) 越小，时间复杂度越低。  </p><h4 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h4><p>  上面做法就是，先算出基础操作的次数，然后再找出它的同数量级，最后比一下为常数。栗子如下：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line"></span><br><span class="line">for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">  for(int j = 0; j &lt; n; j++)&#123;</span><br><span class="line">    s = i;//基本操作执行次数：n^2</span><br><span class="line">    for(int k = 0; k &lt; n; k++)&#123;</span><br><span class="line">        s += j + k;//基本操作执行次数：n^3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  总次数为 T（n）&#x3D; n^2 + n^3，同数量级的一般取数量级高的 n^3，最后 T(n)&#x2F;f(n) &#x3D; 1&#x2F;n + 1，当 n 趋近无穷时，T(n)&#x2F;f(n) &#x3D; 1，为一个常数，所以时间复杂度为 O(n^3)<br>  口算的计算方法是：看看有几重 for 循环，只有一重则时间复杂度为 O(n)，二重则为 O(n^2)，依此类推，如果有二分则为 O(logn)，二分例如二分查找，如果一个 for 循环套一个二分，那么时间复杂度则为 O(nlogn)。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h4 id="1、理解：-1"><a href="#1、理解：-1" class="headerlink" title="1、理解："></a>1、理解：</h4><p>  它是指运行算法需要消耗的内存空间，详见百科<a href="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">空间复杂度</a>。  </p><h4 id="2、时间复杂度函数"><a href="#2、时间复杂度函数" class="headerlink" title="2、时间复杂度函数"></a>2、时间复杂度函数</h4><p>  O(1)：表示为一个常量，即不随被处理数据量 n 的大小而改变。<br>  O(log2n)：表示一个算法的空间复杂度与以 2 为底的 n 的对数成正比。<br>  O(n)：表示一个算法的空间复杂度与 n 成线性比例关系。<br>  等等, 以此类推……</p><h2 id="时间复杂度与空间复杂度的关系"><a href="#时间复杂度与空间复杂度的关系" class="headerlink" title="时间复杂度与空间复杂度的关系"></a>时间复杂度与空间复杂度的关系</h2><p>  时间复杂度和空间复杂度往往是相互影响，一个好另一个坏，反之。所以我们常会结合实际的需求来选择牺牲某一个换取另一个。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  选择一个高效的算法，主要是看时间复杂度和空间复杂度，当两者不能同时达到最优时，我们应该根据实际软件的要求，有舍有得，达到在<strong>时间上的高效利用</strong>或<strong>空间上的高效利用</strong>。</p>]]></content>
    
    
    <summary type="html">如何衡量一个算法的好坏</summary>
    
    
    
    <category term="编程" scheme="https://meijhm.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="算法" scheme="https://meijhm.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>介绍一些计算机语言</title>
    <link href="https://meijhm.github.io/2023/06/03/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%BA%9B%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"/>
    <id>https://meijhm.github.io/2023/06/03/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%BA%9B%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/</id>
    <published>2023-06-03T02:29:38.000Z</published>
    <updated>2023-06-14T07:24:50.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非编程语言"><a href="#非编程语言" class="headerlink" title="非编程语言"></a>非编程语言</h2><h3 id="HTML（超文本标记语言）"><a href="#HTML（超文本标记语言）" class="headerlink" title="HTML（超文本标记语言）"></a>HTML（超文本标记语言）</h3><p>    HTML 是一种用于创建网页的标准标记语言。<br>    HTML 是一种基础技术，常与 CSS、JavaScript 一起被众多网站用于设计令人赏心悦目的网页、网页应用程序以及移动应用程序的用户界面。HTML 描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言。<br>  学习参考网站：<a href="http://www.w3school.com.cn/html5/index.asp">W3school html5 教程</a></p><h3 id="CSS（层叠样式表）"><a href="#CSS（层叠样式表）" class="headerlink" title="CSS（层叠样式表）"></a>CSS（层叠样式表）</h3><p>  CSS是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式的样式表语言。也属于计算机语言但非编程语言。<br>  学习参考网站：<a href="http://www.w3school.com.cn/css/index.asp">W3school CSS 教程</a></p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>  Java 是一种计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级 Web 应用开发和移动应用开发。<br>  编程范型：面向对象、结构化、命令式、泛型、反射、并发计算<br>  语言类型：静态、安全、强类型、标明类型（静态类型语言的类型判断是在运行前判断（如编译阶段），动态类型语言，意思就是类型的检查是在运行时做的）<br>  Java 编程语言的风格十分接近 C++ 语言。继承了 C++ 语言面向对象技术的核心，Java 舍弃了 C++ 语言中容易引起错误的指针，改以引用取代，同时移除了 C++ 中的运算符重载和多重继承特性，改用接口取代，增加垃圾回收器功能。在 Java SE 1.5 版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装 &#x2F; 拆箱特性。<br>  Java 不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，然后依赖各种不同平台上的虚拟机来解释执行字节码，从而实现了 “一次编写，到处运行” 的跨平台特性。<br>  Java 语言最大的三个特点：面向对象，跨平台性，自动垃圾回收</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>  C 是一种计算机编程语言，广泛用于系统软件与应用软件的开发。<br>  编程范型：指令式编程，面向过程、结构化编程<br>  C 语言具有高效、灵活、功能丰富、表达力强和较高的可移植性等特点。  </p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>  C++ 是一种计算机编程语言。这种语言被称作 “C with Classes”（“包含‘类’的 C 语言”），作为 C 语言的增强版出现。C++ 是混合型面向对象程序设计语言, 继承并改进了 C 语言, 是一种既支持面向对象又支持面向过程的程序设计语言。<br>  编程范型：面向对象编程，程序编程，泛型编程<br>  语言类型：静态类型，强类型，不安全<br>  C++ 设计成直接的和广泛的支持多种程序设计风格（过程化程序设计、数据抽象、面向对象编程、泛型程序设计）<br>  C++ 设计成尽可能与 C 兼容<br>  C++ 不使用会带来额外开销的特性。<br>  C++ 与 C 的代码执行效率往往相差在 ±5% 之间。</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>  Python 是一种计算机编程语言，是一种解释型语言（Python 解释器解释运行，跨平台），它的设计强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）<br>  编程范型：多泛型、面向对象、指令式编程、函数式编程、程序编程 (过程式编程)、面向切面编程<br>  语言类型：”duck”、动态类型、强类型<br>  与 Scheme、Ruby、Perl、Tcl 等动态类型编程语言一样，Python 拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>  JavaScript 是一种计算机编程语言，通过解释执行，是一门动态类型，面向对象（基于原型）的解释性语言（直译语言）。它提供语法来操控文本、数组、日期以及正则表达式等，但不支持 I&#x2F;O。<br>  编程范型：(客户端) 脚本语言，面向对象（基于原型），指令式，函数式（函数式编程关心数据的映射，命令式编程关心解决问题的步骤）<br>  语言类型：动态类型、弱类型、duck（鸭子类型，是动态类型的一种风格，关注点在于对象的行为，能作什么；而不是关注对象所属的类型，它的一个函数可以接受一个任意类型的对象，并调用它的方法，如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的方法的对象都可被函数接受）<br>  动态化：和大部分脚本语言一样，类型与值而不是与变量关联。例如 x 变量可以为数值，随后又可被赋值为字符串。JavaScript 提供了包括鸭子类型在内的方法来检测变量类型。<br>  它支持许多结构化编程语法（例如 if 条件语句、while 循环、switch 语句、do-while 循环等），它支持函数作用域 (var) 又支持块级作用域(let)。JavaScript 支持自动在语句末添加分号，但建议要在语句末尾加上分号。</p><h3 id="PHP-超文本预处理器"><a href="#PHP-超文本预处理器" class="headerlink" title="PHP(超文本预处理器)"></a>PHP(超文本预处理器)</h3><p>  PHP 是一种计算机编程语言，一种通用的服务器端脚本语言，尤其适用于网络开发并可嵌入 HTML 中使用。PHP 的语法借鉴吸收 C 语言、Java 和 Perl 等流行计算机语言的特点。PHP 的主要目标是允许网络开发人员快速编写动态页面，但 PHP 也被用于其他很多领域。<br>  编程范型：(服务器端) 脚本语言、面向对象、指令式编程<br>  语言类型：动态类型、弱类型 (为变量赋值时会自动判断类型并进行转换)<br>  PHP 可以用三种注解的形式：C 与 C++ 所使用的 “&#x2F;<em>…</em>&#x2F;” 与 “&#x2F;&#x2F;”，和 Perl 的 “#”。<br>  PHP 主要有八种基本数据类型：<br>  四种变量类型：整数型（integer），浮点数型（float），布尔型（boolean），字符串（string）<br>  两种复合类型：数组（array），对象（object）<br>  两种特殊类型：NULL，资源 （resource）<br>  PHP 中，变量以 “$” 后接变量名称来表示。 变量名称区分大小写（函数名不区分大小写）。有效的变量名称以字母或下划线开头，后接任意数目的字母、数字或下划线，PHP 也支持使用多字节文字作为变量名。（就是 C 语言的多字节字符，西方文字就是一个字节表示一个字符，如 ASCII 字符集。而东亚一些国家的文字，很多都是多个字节表示一个字符，如中文、韩文、日文等）<br>  学习参考网站：<a href="http://be2.php.net/manual/zh/index.php">PHP 手册</a></p>]]></content>
    
    
    <summary type="html">常见计算机语言简要介绍</summary>
    
    
    
    <category term="编程" scheme="https://meijhm.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://meijhm.github.io/tags/java/"/>
    
    <category term="html" scheme="https://meijhm.github.io/tags/html/"/>
    
    <category term="css" scheme="https://meijhm.github.io/tags/css/"/>
    
    <category term="c" scheme="https://meijhm.github.io/tags/c/"/>
    
    <category term="c++" scheme="https://meijhm.github.io/tags/c/"/>
    
    <category term="python" scheme="https://meijhm.github.io/tags/python/"/>
    
    <category term="JavaScript" scheme="https://meijhm.github.io/tags/JavaScript/"/>
    
    <category term="php" scheme="https://meijhm.github.io/tags/php/"/>
    
  </entry>
  
</feed>
